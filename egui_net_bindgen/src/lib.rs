#![feature(formatting_options)]
#![feature(let_chains)]

use convert_case::*;
use egui::*;
use egui::ecolor::*;
use egui::emath::*;
use egui::epaint::*;
use egui::epaint::Primitive;
use egui::epaint::text::*;
use egui::epaint::text::cursor::*;
use egui::Id;
use egui::collapsing_header::*;
use egui::containers::menu::*;
use egui::layers::*;
use egui::load::*;
use egui::os::*;
use egui::output::*;
use egui::panel::*;
use egui::scroll_area::*;
use egui::style::*;
use egui::text::*;
use egui::text_edit::*;
use egui::text_selection::*;
use egui::text_selection::visuals::*;
use egui::util::undoer::*;
use rustdoc_types::*;
use rustdoc_types::Id as RdId;
use rustdoc_types::Path as RdPath;
use serde_generate::*;
use serde_generate::csharp::*;
use serde_reflection::*;
use std::borrow::*;
use std::collections::*;
use std::path::*;

/// Functions to exclude when automatically generating bindings.
const BINDING_EXCLUDE_FNS: &[&str] = &[
    // These functions return references which need to be converted to values
    "egui_text_selection_text_cursor_state_slice_char_range",

    "egui_ui_Ui_spacing",
    "egui_ui_Ui_spacing_mut",
    "egui_layers_GraphicLayers_entry",
    "egui_ui_Ui_style_mut",
    "egui_ui_Ui_style",
    "egui_ui_Ui_layout",
    "egui_ui_Ui_visuals",
    //"egui_ui_Ui_visuals_mut",
    "egui_ui_Ui_stack",

    // These functions have conflicting names with fields or C#
    "epaint_image_AlphaFromCoverage_alpha_from_coverage",
    "epaint_shapes_shape_Shape_mesh",
    "egui_atomics_atom_kind_AtomKind_text",
    "egui_atomics_atom_kind_AtomKind_image",
    "egui_widget_text_WidgetText_text",
    "epaint_shapes_shape_Shape_text",

    "egui_style_Style_text_styles",
    "egui_style_Visuals_noninteractive",
    "egui_text_selection_cursor_range_CursorRange_on_event",

    "egui_ui_stack_UiStack_frame",

    // These functions have weird parameter types or generics
    "epaint_image_ColorImage_region_by_pixels",
    "epaint_shapes_bezier_shape_CubicBezierShape_split_range",
    "epaint_shapes_shape_Shape_line_segment",
    "egui_data_output_WidgetInfo_text_selection_changed",
    "egui_ui_Ui_new_child",
    "egui_ui_Ui_child_ui",
    "egui_ui_Ui_child_ui_with_id_source",
    "ecolor_hsva_Hsva_from_additive_srgb",
    "ecolor_hsva_Hsva_from_srgba_unmultiplied",
    "ecolor_hsva_Hsva_from_srgba_premultiplied",
    "ecolor_hsva_Hsva_from_srgb",
    "ecolor_hsva_rgb_from_hsv",
    "ecolor_hsva_hsv_from_rgb",
    "emath_format_with_decimals_in_range",

    // These functions generate as properties, but should be methods
    "egui_ui_Ui_separator",

    // Grid: bound manually
    "egui_grid_Grid_striped",

    // Popup: bound manually
    "egui_containers_popup_Popup_open_id",

    // Rect: bound manually
    "emath_rect_Rect_center",
    "emath_rect_Rect_set_center",
];

/// Types to exclude from generation.
const BINDING_EXCLUDE_TYPES: &[&str] = &[
    "History",
    "SubMenuButton",
    // Private types
    "Tessellator"
];

/// Types for which fields/serialization logic should not be generated.
const BINDING_EXCLUDE_TYPE_DEFINITIONS: &[&str] = &[
    "Color32",
    "DragPanButtons",
    "Id",
    "Response",
    "Sense",
    "UiStack"
];

/// Types that should be converted to `class`es in C# backed by opaque handles.
const HANDLE_TYPES: &[&str] = &[
    "Context",
    "Fonts",
    "Painter",
    "TextureHandle",
];

/// Types that should be converted to `ref struct`s in C# backed by pointers.
const POINTER_TYPES: &[&str] = &[
    "Ui"
];

/// Changes the names of autogenerated namespaces.
const NAMESPACE_RENAMES: &[(&str, &str)] = &[
    ("Egui.Containers.ScrollArea", "Egui.Containers"),
    ("Egui.Containers.CollapsingHeader", "Egui.Containers"),
    ("Egui.Os", "Egui"),
    ("Egui.Response", "Egui"),
    ("Egui.Style", "Egui"),
    ("Egui.TextSelection.TextCursorState", "Egui.TextSelection"),
    ("Egui.TextSelection.Visuals", "Egui.TextSelection"),
    ("Egui.Widgets", "Egui"),
    ("Egui.Widgets.ColorPicker", "Egui"),
    ("Egui.Widgets.TextEdit", "Egui")
];

/// Customizes the assigned namespace of types.
const NAMESPACE_OVERRIDES: &[(&str, &str)] = &[
];

/// Custom function names to define.
const CUSTOM_FNS: &[&str] = &[
    "egui_context_Context_ref_decrement",
    "egui_context_Context_ref_count",
    "egui_context_Context_ref_id",
    "egui_ui_Ui_set_enabled"
];

/// A list of fully-qualified function IDs to ignore during generation.
const IGNORE_FNS: &[&str] = &[
    // Random extra stuff which we don't want that got lumped into documentation
    "alloc_borrow_Cow_as_str",
    "alloc_borrow_Cow_clear",
    "alloc_borrow_Cow_delete_char_range",
    "alloc_borrow_Cow_insert_text",
    "alloc_borrow_Cow_is_mutable",
    "alloc_borrow_Cow_replace_with",
    "alloc_borrow_Cow_take",
    "alloc_string_String_as_str",
    "alloc_string_String_clear",
    "alloc_string_String_delete_char_range",
    "alloc_string_String_insert_text",
    "alloc_string_String_is_mutable",
    "alloc_string_String_replace_with",
    "alloc_string_String_take",
    "alloc_borrow_Cow_type_id",
    "alloc_string_String_type_id",
    "ab_glyph_outlined_Outline",
    "ab_glyph_outlined_OutlineCurve",
    "ahash_random_state_RandomState",
    "alloc_collections_btree_map_Keys",
    "alloc_collections_btree_map_ValuesMut",
    "alloc_collections_btree_map_drop_DropGuard",
    "alloc_vec_drain_drop_DropGuard",
    "core_cell_BorrowRefMut",
    "core_char_decode_DecodeUtf16",
    "core_convert_num_FloatToInt",
    "core_core_arch_simd_u32x4",
    "core_core_arch_simd_u64x4",
    "core_core_arch_x86___m128i",
    "core_core_simd_simd_num_int_SimdInt",
    "core_error_Source",
    "core_fmt_UpperExp",
    "core_iter_adapters_map_while_MapWhile",
    "core_num_nonzero_NonZeroU128_from_f64",
    "core_num_nonzero_NonZeroU128_to_f64",
    "core_num_nonzero_NonZeroU16_from_f64",
    "core_num_nonzero_NonZeroU16_to_f64",
    "core_num_nonzero_NonZeroU32_from_f64",
    "core_num_nonzero_NonZeroU32_to_f64",
    "core_num_nonzero_NonZeroU64_from_f64",
    "core_num_nonzero_NonZeroU64_to_f64",
    "core_num_nonzero_NonZeroU8_from_f64",
    "core_num_nonzero_NonZeroU8_to_f64",
    "core_num_nonzero_NonZeroUsize_from_f64",
    "core_num_nonzero_NonZeroUsize_to_f64",
    "core_pat_RangePattern",
    "core_ptr_unique_Unique",
    "core_slice_iter_RSplitMut",
    "core_str_iter_EscapeDefault",
    "core_str_iter_MatchIndicesInternal",
    "core_sync_atomic_AtomicU16",
    "core_task_wake_LocalWaker",
    "core_core_arch_x86_splat_JustOne",
    "core_core_arch_simd_splat_JustOne",
    "ab_glyph_font_arc_FontArc",
    "alloc_alloc_Global",
    "alloc_alloc_alloc",
    "alloc_collections_btree_set_Range",
    "alloc_collections_vec_deque_iter_mut_IterMut",
    "compiler_builtins_int_big_u256",
    "compiler_builtins_math_libm_support_env_Round",
    "core_array_iter_IntoIter",
    "core_clone_uninit_InitializingSlice",
    "core_core_arch_simd_i32x32",
    "core_core_simd_simd_ptr_mut_ptr_SimdMutPtr",
    "core_error_private_Internal",
    "core_future_ready_Ready",
    "core_iter_adapters_map_Map",
    "core_iter_adapters_map_windows_Buffer",
    "core_iter_adapters_skip_Skip",
    "core_marker_ConstParamTy_",
    "core_marker_PhantomData",
    "core_num_fmt_Formatted",
    "core_ops_arith_Neg",
    "core_ops_async_function_AsyncFnOnce",
    "core_ops_try_trait_Try",
    "core_ptr_with_exposed_provenance",
    "core_slice_iter_ChunksExactMut",
    "core_slice_iter_RSplit",
    "core_sync_atomic_AtomicU32",
    "core_sync_exclusive_Exclusive",
    "hashbrown_raw_RawTable",
    "lock_api_rwlock_RawRwLockRecursive",
    "once_cell",
    "rustc_demangle_TryDemangleError",
    "serde___private_de_StrDeserializer",
    "serde___private_ser_FlatMapSerializeTupleVariantAsMapValue",
    "serde_de_impls_deserialize_BoundVisitor",
    "serde_de_impls_deserialize_SocketAddrKind",
    "std_backtrace_rs_dbghelp_Init",
    "std_backtrace_rs_windows_sys_CONTEXT_0_0",
    "std_backtrace_rs_windows_sys_KNONVOLATILE_CONTEXT_POINTERS_1",
    "std_backtrace_rs_windows_sys_STACKFRAME64",
    "std_backtrace_rs_windows_sys_STACKFRAME_EX",
    "std_backtrace_rs_windows_sys_SYMBOL_INFOW",
    "std_collections_hash_map_OccupiedEntry",
    "std_collections_hash_map_VacantEntry",
    "std_collections_hash_set_Intersection",
    "std_f16",
    "std_io_stdio_StdinRaw",
    "std_panic_PanicHookInfo",
    "std_process_ChildStdin",
    "std_sys_net_connection_socket_TcpListener",
    "std_sys_pal_windows_c_windows_sys_CONSOLE_READCONSOLE_CONTROL",
    "std_sys_pal_windows_c_windows_sys_SYSTEM_INFO_0_0",
    "std_thread_local_AccessError",
    "ttf_parser_NormalizedCoordinate",
    "ttf_parser_ggg_feature_variations_FeatureVariations",
    "ttf_parser_parser_LazyArrayIter16",
    "ttf_parser_parser_Stream",
    "ttf_parser_tables_cff_encoding_Supplement",
    "ttf_parser_tables_feat_FeatureNames",
    "ttf_parser_tables_kerx_Subtable1",
    "ttf_parser_tables_morx_Chain",
    "ttf_parser_tables_morx_Coverage",
    "ttf_parser_tables_svg_SvgDocumentsList",
    "ttf_parser_tables_trak_TrackTableRecord",
    "zerocopy_AsBytes",
    "ab_glyph_font_Font",
    "alloc_collections_btree_append_MergeIter",
    "alloc_collections_btree_map_RangeMut",
    "alloc_collections_btree_set_Iter",
    "alloc_collections_btree_set_val_SetValZST",
    "alloc_ffi_c_str_NulError",
    "alloc_vec",
    "alloc_vec_drain_Drain",
    "bitflags_parser_ParseErrorKind",
    "compiler_builtins_math_libm_fma_Norm",
    "core_core_arch_simd_i8x32",
    "core_core_arch_simd_m16x16",
    "core_core_arch_simd_u32x2",
    "core_fmt_Arguments",
    "core_marker_UnsizedConstParamTy",
    "core_net_ip_addr_Ipv6MulticastScope",
    "core_ops_bit_Shl",
    "core_ops_range_Bound",
    "core_ops_range_RangeBounds",
    "core_ptr_without_provenance",
    "core_slice_iter_SplitInclusiveMut",
    "core_str_BytesIsNotEmpty",
    "core_str_pattern_MultiCharEqSearcher",
    "core_str_pattern_SearchStep",
    "epaint_texture_handle_TextureHandle_drop",
    "epaint_shapes_paint_callback_PaintCallbackInfo_clip_rect_in_pixels",
    "epaint_shapes_paint_callback_PaintCallbackInfo_viewport_in_pixels",
    "egui_containers_frame_Frame_show_dyn",

    // AllocatedAtomLayout: bound manually
    "egui_atomics_atom_layout_AllocatedAtomLayout_iter_kinds",
    "egui_atomics_atom_layout_AllocatedAtomLayout_iter_kinds_mut",
    "egui_atomics_atom_layout_AllocatedAtomLayout_map_kind",

    // Atoms: bound manually
    "egui_atomics_atoms_Atoms_from_iter",
    "egui_atomics_atoms_Atoms_into_iter",
    "egui_atomics_atoms_Atoms_iter_kinds",
    "egui_atomics_atoms_Atoms_iter_kinds_mut",
    "egui_atomics_atoms_Atoms_map_kind",
    "egui_atomics_atoms_Atoms_map_atoms",

    // FontsImpl: private type
    "epaint_text_fonts_FontsImpl_definitions",
    "epaint_text_fonts_FontsImpl_font",
    "epaint_text_fonts_FontsImpl_has_glyph",
    "epaint_text_fonts_FontsImpl_has_glyphs",
    "epaint_text_fonts_FontsImpl_new",
    "epaint_text_fonts_FontsImpl_pixels_per_point",

    // Mutex: private type
    "epaint_mutex_mutex_impl_Mutex_default",
    "epaint_mutex_mutex_impl_Mutex_lock",
    "epaint_mutex_mutex_impl_Mutex_new",
    "epaint_mutex_rw_lock_impl_RwLock_default",
    "epaint_mutex_rw_lock_impl_RwLock_new",
    "epaint_mutex_rw_lock_impl_RwLock_read",
    "epaint_mutex_rw_lock_impl_RwLock_write",

    // CacheStorage: not possible to bind to C# due to generics
    "egui_cache_cache_storage_CacheStorage_cache",
    "egui_cache_cache_storage_CacheStorage_default",
    "egui_cache_cache_storage_CacheStorage_update",

    // Context: manually-defined functions
    "egui_context_Context_style_mut",
    "egui_context_Context_style_mut_of",

    // Frame: redudant function (same as NONE)
    "egui_containers_frame_Frame_new",

    // DragPanButtons: bindings are written manually 
    "egui_containers_scene_DragPanButtons_all",
    "egui_containers_scene_DragPanButtons_bitand",
    "egui_containers_scene_DragPanButtons_bitand_assign",
    "egui_containers_scene_DragPanButtons_bitor",
    "egui_containers_scene_DragPanButtons_bitor_assign",
    "egui_containers_scene_DragPanButtons_bitxor",
    "egui_containers_scene_DragPanButtons_bitxor_assign",
    "egui_containers_scene_DragPanButtons_complement",
    "egui_containers_scene_DragPanButtons_contains",
    "egui_containers_scene_DragPanButtons_default",
    "egui_containers_scene_DragPanButtons_difference",
    "egui_containers_scene_DragPanButtons_empty",
    "egui_containers_scene_DragPanButtons_extend",
    "egui_containers_scene_DragPanButtons_from_bits_truncate",
    "egui_containers_scene_DragPanButtons_from_iter",
    "egui_containers_scene_DragPanButtons_from_name",
    "egui_containers_scene_DragPanButtons_insert",
    "egui_containers_scene_DragPanButtons_intersection",
    "egui_containers_scene_DragPanButtons_intersects",
    "egui_containers_scene_DragPanButtons_into_iter",
    "egui_containers_scene_DragPanButtons_is_all",
    "egui_containers_scene_DragPanButtons_is_empty",
    "egui_containers_scene_DragPanButtons_iter",
    "egui_containers_scene_DragPanButtons_iter_names",
    "egui_containers_scene_DragPanButtons_not",
    "egui_containers_scene_DragPanButtons_remove",
    "egui_containers_scene_DragPanButtons_set",
    "egui_containers_scene_DragPanButtons_symmetric_difference",
    "egui_containers_scene_DragPanButtons_toggle",
    "egui_containers_scene_DragPanButtons_union",

    // FontData: redundant function
    "epaint_text_fonts_FontData_from_static",

    // History: not possible to bind to C# due to generics
    "emath_history_History_average",
    "emath_history_History_bandwidth",
    "emath_history_History_clear",
    "emath_history_History_duration",
    "emath_history_History_flush",
    "emath_history_History_is_empty",
    "emath_history_History_iter",
    "emath_history_History_latest",
    "emath_history_History_latest_mut",
    "emath_history_History_len",
    "emath_history_History_max_age",
    "emath_history_History_max_len",
    "emath_history_History_mean_time_interval",
    "emath_history_History_new",
    "emath_history_History_rate",
    "emath_history_History_sum",
    "emath_history_History_total_count",
    "emath_history_History_values",
    "emath_history_History_velocity",

    // IdTypeMap: not possible to bind to C# due to generics
	"egui_util_id_type_map_IdTypeMap_clear",
	"egui_util_id_type_map_IdTypeMap_count",
	"egui_util_id_type_map_IdTypeMap_count_serialized",
	"egui_util_id_type_map_IdTypeMap_default",
	"egui_util_id_type_map_IdTypeMap_get_persisted",
	"egui_util_id_type_map_IdTypeMap_get_persisted_mut_or",
	"egui_util_id_type_map_IdTypeMap_get_persisted_mut_or_default",
	"egui_util_id_type_map_IdTypeMap_get_persisted_mut_or_insert_with",
	"egui_util_id_type_map_IdTypeMap_get_temp",
	"egui_util_id_type_map_IdTypeMap_get_temp_mut_or",
	"egui_util_id_type_map_IdTypeMap_get_temp_mut_or_default",
	"egui_util_id_type_map_IdTypeMap_get_temp_mut_or_insert_with",
	"egui_util_id_type_map_IdTypeMap_insert_persisted",
	"egui_util_id_type_map_IdTypeMap_insert_temp",
	"egui_util_id_type_map_IdTypeMap_is_empty",
	"egui_util_id_type_map_IdTypeMap_len",
	"egui_util_id_type_map_IdTypeMap_max_bytes_per_type",
	"egui_util_id_type_map_IdTypeMap_remove",
	"egui_util_id_type_map_IdTypeMap_remove_by_type",
	"egui_util_id_type_map_IdTypeMap_remove_temp",
	"egui_util_id_type_map_IdTypeMap_set_max_bytes_per_type",
    "egui_util_id_type_map_TypeId_of",

    // Scene: redundant function (same as default)
    "egui_containers_scene_Scene_new",

    // Sides: redundant function (same as default)
    "egui_containers_sides_Sides_new",

    // SubMenu: redundant function (same as default)
    "egui_containers_menu_SubMenu_new",

    // MenuBar: redundant function (same as default)
    "egui_containers_menu_MenuBar_new",

    // MenuConfig: redundant function (same as default)
    "egui_containers_menu_MenuConfig_new",

    // old_popup: deprecated
    "egui_containers_old_popup_popup_above_or_below_widget",
    "egui_containers_old_popup_popup_below_widget",
    "egui_containers_old_popup_show_tooltip",
    "egui_containers_old_popup_show_tooltip_at",
    "egui_containers_old_popup_show_tooltip_at_pointer",
    "egui_containers_old_popup_show_tooltip_for",
    "egui_containers_old_popup_show_tooltip_text",
    "egui_containers_old_popup_was_tooltip_open_last_frame",

    // Layout: method definitions are just gettings for public fields
    "egui_layout_Layout_cross_align",
    "egui_layout_Layout_cross_justify",
    "egui_layout_Layout_main_align",
    "egui_layout_Layout_main_dir",
    "egui_layout_Layout_main_justify",
    "egui_layout_Layout_main_wrap",

    // MenuState: deprecated functions (old type definition)
    "egui_menu_MenuState_area_contains",
    "egui_menu_MenuState_new",

    // Painter: bound manually
    "egui_painter_Painter_ctx",

    // Rect: bound manually
    "emath_rect_Rect_bottom",
    "emath_rect_Rect_bottom_mut",
    "emath_rect_Rect_set_bottom",
    "emath_rect_Rect_top",
    "emath_rect_Rect_top_mut",
    "emath_rect_Rect_set_top",
    "emath_rect_Rect_left",
    "emath_rect_Rect_left_mut",
    "emath_rect_Rect_set_left",
    "emath_rect_Rect_right",
    "emath_rect_Rect_right_mut",
    "emath_rect_Rect_set_right",
    "emath_rect_Rect_height",
    "emath_rect_Rect_set_height",
    "emath_rect_Rect_width",
    "emath_rect_Rect_set_width",

    // Response: bound manually
    "egui_response_Response_context_menu",
    "egui_response_Response_on_disabled_hover_ui",
    "egui_response_Response_on_hover_ui",
    "egui_response_Response_on_hover_ui_at_pointer",
    "egui_response_Response_show_tooltip_ui",

    // Sense: bound manually
    "egui_sense_Sense_all",
    "egui_sense_Sense_bitand",
    "egui_sense_Sense_bitand_assign",
    "egui_sense_Sense_bitor",
    "egui_sense_Sense_bitor_assign",
    "egui_sense_Sense_bitxor",
    "egui_sense_Sense_bitxor_assign",
    "egui_sense_Sense_click",
    "egui_sense_Sense_click_and_drag",
    "egui_sense_Sense_clone",
    "egui_sense_Sense_complement",
    "egui_sense_Sense_contains",
    "egui_sense_Sense_difference",
    "egui_sense_Sense_drag",
    "egui_sense_Sense_empty",
    "egui_sense_Sense_extend",
    "egui_sense_Sense_focusable_noninteractive",
    "egui_sense_Sense_from_bits_truncate",
    "egui_sense_Sense_from_iter",
    "egui_sense_Sense_from_name",
    "egui_sense_Sense_hover",
    "egui_sense_Sense_insert",
    "egui_sense_Sense_intersection",
    "egui_sense_Sense_intersects",
    "egui_sense_Sense_into_iter",
    "egui_sense_Sense_is_all",
    "egui_sense_Sense_is_empty",
    "egui_sense_Sense_iter",
    "egui_sense_Sense_iter_names",
    "egui_sense_Sense_not",
    "egui_sense_Sense_remove",
    "egui_sense_Sense_set",
    "egui_sense_Sense_sub",
    "egui_sense_Sense_sub_assign",
    "egui_sense_Sense_symmetric_difference",
    "egui_sense_Sense_toggle",
    "egui_sense_Sense_union",

    // AllocInfo: private type
    "epaint_stats_AllocInfo_default",
    "epaint_stats_AllocInfo_format",
    "epaint_stats_AllocInfo_from_galley",
    "epaint_stats_AllocInfo_from_mesh",
    "epaint_stats_AllocInfo_from_slice",
    "epaint_stats_AllocInfo_megabytes",
    "epaint_stats_AllocInfo_num_allocs",
    "epaint_stats_AllocInfo_num_bytes",
    "epaint_stats_AllocInfo_num_elements",
    "epaint_stats_AllocInfo_sum",

    // Path: private type
    "epaint_tessellator_Path_add_circle",
    "epaint_tessellator_Path_add_line_loop",
    "epaint_tessellator_Path_add_line_segment",
    "epaint_tessellator_Path_add_open_points",
    "epaint_tessellator_Path_add_point",
    "epaint_tessellator_Path_clear",
    "epaint_tessellator_Path_default",
    "epaint_tessellator_Path_fill",
    "epaint_tessellator_Path_fill_and_stroke",
    "epaint_tessellator_Path_fill_with_uv",
    "epaint_tessellator_Path_reserve",
    "epaint_tessellator_Path_stroke",
    "epaint_tessellator_Path_stroke_closed",
    "epaint_tessellator_Path_stroke_open",
    "epaint_tessellator_path_add_circle_quadrant",
    "epaint_tessellator_path_rounded_rectangle",

    // PaintStats: private type
    "epaint_stats_PaintStats_default",
    "epaint_stats_PaintStats_from_shapes",
    "epaint_stats_PaintStats_with_clipped_primitives",

    // Popup: manually bound
    "egui_containers_popup_PopupCloseBehavior_default",
    "egui_containers_popup_Popup_align",
    "egui_containers_popup_Popup_align_alternatives",
    "egui_containers_popup_Popup_anchor",
    "egui_containers_popup_Popup_at_pointer",
    "egui_containers_popup_Popup_at_pointer_fixed",
    "egui_containers_popup_Popup_at_position",
    "egui_containers_popup_Popup_close_behavior",
    "egui_containers_popup_Popup_ctx",
    "egui_containers_popup_Popup_gap",
    "egui_containers_popup_Popup_id",
    "egui_containers_popup_Popup_info",
    "egui_containers_popup_Popup_open",
    "egui_containers_popup_Popup_open_bool",
    "egui_containers_popup_Popup_id",
    "egui_containers_popup_Popup_kind",
    "egui_containers_popup_Popup_sense",
    "egui_containers_popup_Popup_style",
    "egui_containers_popup_Popup_width",
    "egui_containers_popup_Popup_open_memory",
    "egui_containers_popup_Popup_new",
    "egui_containers_popup_Popup_menu",
    "egui_containers_popup_Popup_layout",
    "egui_containers_popup_Popup_is_open",
    "egui_containers_popup_Popup_frame",
    "egui_containers_popup_Popup_context_menu",
    "egui_containers_popup_Popup_default_response_id",
    "egui_containers_popup_Popup_from_response",
    "egui_containers_popup_Popup_from_toggle_button_response",
    "egui_containers_popup_PopupAnchor_rect",
    "egui_containers_popup_Popup_get_id",
    "egui_containers_popup_Popup_get_anchor_rect",
    "egui_containers_popup_Popup_get_popup_rect",
    "egui_containers_popup_Popup_get_anchor",
    "egui_containers_popup_Popup_get_best_align",
    "egui_containers_popup_Popup_get_expected_size",

    // Spinner: redundant function (same as default)
    "egui_widgets_spinner_Spinner_new",

    // Tessellator: private type
    "epaint_tessellator_Tessellator_new",
    "epaint_tessellator_Tessellator_set_clip_rect",
    "epaint_tessellator_Tessellator_tessellate_circle",
    "epaint_tessellator_Tessellator_tessellate_clipped_shape",
    "epaint_tessellator_Tessellator_tessellate_cubic_bezier",
    "epaint_tessellator_Tessellator_tessellate_ellipse",
    "epaint_tessellator_Tessellator_tessellate_line",
    "epaint_tessellator_Tessellator_tessellate_line_segment",
    "epaint_tessellator_Tessellator_tessellate_mesh",
    "epaint_tessellator_Tessellator_tessellate_path",
    "epaint_tessellator_Tessellator_tessellate_quadratic_bezier",
    "epaint_tessellator_Tessellator_tessellate_rect",
    "epaint_tessellator_Tessellator_tessellate_shape",
    "epaint_tessellator_Tessellator_tessellate_shapes",
    "epaint_tessellator_Tessellator_tessellate_text",
    "epaint_shapes_path_shape_PathShape",
    "epaint_tessellator_Tessellator",
    "egui_load_Result_Ok",
    "emath_rect_transform_RectTransform",
    "egui_widget_text_RichText_collect",

    // Prepared: omitted due to safety conflicts (Ui cannot be owned in the current C# API)
    "egui_containers_frame_Frame_begin",
    "egui_containers_frame_Prepared_allocate_space",
    "egui_containers_frame_Prepared_end",
    "egui_containers_frame_Prepared_paint",

    // UiBuilder: redundant function (same as default)
    "egui_ui_builder_UiBuilder_new",

    // Ui
    "egui_ui_Ui_ctx",
    "egui_ui_Ui_drop",

    // ViewportInPixels: private type
    "epaint_viewport_ViewportInPixels_from_points",

    // Undoer: not possible to bind to C# due to generics
    "egui_util_undoer_Undoer_add_undo",
    "egui_util_undoer_Undoer_default",
    "egui_util_undoer_Undoer_feed_state",
    "egui_util_undoer_Undoer_has_redo",
    "egui_util_undoer_Undoer_has_undo",
    "egui_util_undoer_Undoer_is_in_flux",
    "egui_util_undoer_Undoer_redo",
    "egui_util_undoer_Undoer_undo",
    "egui_util_undoer_Undoer_with_settings",

    // Window: manually bound
    "egui_containers_window_Window_anchor",
    "egui_containers_window_Window_auto_sized",
    "egui_containers_window_Window_collapsible",
    "egui_containers_window_Window_constrain",
    "egui_containers_window_Window_constrain_to",
    "egui_containers_window_Window_current_pos",
    "egui_containers_window_Window_default_height",
    "egui_containers_window_Window_default_open",
    "egui_containers_window_Window_default_pos",
    "egui_containers_window_Window_default_rect",
    "egui_containers_window_Window_default_size",
    "egui_containers_window_Window_default_width",
    "egui_containers_window_Window_drag_to_scroll",
    "egui_containers_window_Window_enabled",
    "egui_containers_window_Window_fade_in",
    "egui_containers_window_Window_fade_out",
    "egui_containers_window_Window_fixed_pos",
    "egui_containers_window_Window_fixed_rect",
    "egui_containers_window_Window_fixed_size",
    "egui_containers_window_Window_frame",
    "egui_containers_window_Window_hscroll",
    "egui_containers_window_Window_id",
    "egui_containers_window_Window_interactable",
    "egui_containers_window_Window_max_height",
    "egui_containers_window_Window_max_size",
    "egui_containers_window_Window_max_width",
    "egui_containers_window_Window_min_height",
    "egui_containers_window_Window_min_size",
    "egui_containers_window_Window_min_width",
    "egui_containers_window_Window_movable",
    "egui_containers_window_Window_new",
    "egui_containers_window_Window_open",
    "egui_containers_window_Window_order",
    "egui_containers_window_Window_pivot",
    "egui_containers_window_Window_resizable",
    "egui_containers_window_Window_resize",
    "egui_containers_window_Window_scroll",
    "egui_containers_window_Window_scroll_bar_visibility",
    "egui_containers_window_Window_title_bar",
    "egui_containers_window_Window_vscroll",
    "egui_containers_window_Window_mutate",

    // FramePublisher: not possible to bind to C# due to generics
    "egui_cache_frame_publisher_FramePublisher_as_any_mut",
    "egui_cache_frame_publisher_FramePublisher_default",
    "egui_cache_frame_publisher_FramePublisher_evict_cache",
    "egui_cache_frame_publisher_FramePublisher_get",
    "egui_cache_frame_publisher_FramePublisher_len",
    "egui_cache_frame_publisher_FramePublisher_new",
    "egui_cache_frame_publisher_FramePublisher_set",
    "egui_cache_frame_publisher_FramePublisher_update",

    // FrameCache: not possible to bind to C# due to generics
    "egui_cache_frame_cache_FrameCache_as_any_mut",
    "egui_cache_frame_cache_FrameCache_default",
    "egui_cache_frame_cache_FrameCache_evict_cache",
    "egui_cache_frame_cache_FrameCache_get",
    "egui_cache_frame_cache_FrameCache_len",
    "egui_cache_frame_cache_FrameCache_new",
    "egui_cache_frame_cache_FrameCache_update",

    // StyleModifier: not possible to bind to C# due to callbacks
    "egui_style_StyleModifier_apply",
    "egui_style_StyleModifier_default",
    "egui_style_StyleModifier_new",

    // Ui: manually bound
    "egui_ui_Ui_allocate_ui",
    "egui_ui_Ui_columns_const",
    "egui_ui_Ui_add_sized",
    "egui_ui_Ui_put",
    "egui_ui_Ui_add_enabled",
    "egui_ui_Ui_add_enabled_ui",
    "egui_ui_Ui_scope_dyn",
    "egui_ui_Ui_scope",
    "egui_ui_Ui_add_visible",
    "egui_ui_Ui_collapsing",
    "egui_ui_Ui_radio_value",
    "egui_ui_Ui_selectable_value",

    // Other functions that cannot be bound to C#
    "epaint_stroke_PathStroke_new_uv",
    "epaint_util_hash_with",
    
    "egui___run_test_ctx",
    "egui___run_test_ui",
    "egui_debug_text_print",

    "serde_de_impls_deserialize_NonZeroVisitor",
    "serde_de_impls_deserialize_in_place_TupleInPlaceVisitor",
    "egui_warn_if_debug_build"
];

/// Function names to be ignored during generation.
const IGNORE_FN_NAMES: &[&str] = &[
    "add",
    "add_assign",
    "as_ref",
    "bitand",
    "bitand_assign",
    "bitor",
    "bitor_assign",
    "bits",
    "borrow",
    "clone",
    "cmp",
    "deref",
    "deref_mut",
    "deserialize",
    "div",
    "div_assign",
    "eq",
    "hash",
    "fmt",
    "from",
    "from_bits",
    "from_bits_retain",
    "index",
    "index_mut",
    "mul",
    "mul_assign",
    "partial_cmp",
    "serialize",
    "sub",
    "sub_assign",
    "value"
];

include!(concat!(env!("OUT_DIR"), "/tracer.rs"));

/// Holds context for use during bindings generation.
pub struct BindingsGenerator {
    /// A mapping from item IDs to their declaring types.
    declaring_tys: HashMap<RdId, RdId>,
    /// Metadata about the crate being generated.
    krate: Crate,
    /// The output path to which data will be written.
    output_path: PathBuf,
    /// A registry of reflected information about `egui` types.
    registry: Registry,
    /// Maps from simple names to C# namespaces.
    namespaces: HashMap<String, String>,
    /// Maps a type name to its ID.
    name_to_id: HashMap<String, RdId>,
    /// A list of public fields on every struct type.
    public_fields: HashSet<(String, String)>
}

impl BindingsGenerator {
    /// Creates autogenerated bindings for all `serde` types.
    pub fn generate(path: &std::path::Path) {
        let mut krate = serde_json::from_str::<Crate>(include_str!("egui.json")).expect("Failed to parse egui");
        Self::merge_crates(&mut krate, &serde_json::from_str::<Crate>(include_str!("emath.json")).expect("Failed to parse emath"));
        Self::merge_crates(&mut krate, &serde_json::from_str::<Crate>(include_str!("epaint.json")).expect("Failed to parse epaint"));
        Self::merge_crates(&mut krate, &serde_json::from_str::<Crate>(include_str!("ecolor.json")).expect("Failed to parse epaint"));
        let declaring_tys = Self::declaring_types(&krate);
        let name_to_id = Self::names_to_ids(&krate);
        let public_fields = Self::public_fields(&krate);

        let mut namespaces = Self::find_public_paths(&krate, &["egui", "epaint", "emath", "ecolor"])
            .into_iter().map(|(name, mut path)| {
                path.pop();
                for segment in &mut path {
                    *segment = segment.to_case(Case::Pascal);
                }
                (name, path.join("."))
            }).chain(NAMESPACE_OVERRIDES.iter().map(|(a, b)| (a.to_string(), b.to_string()))).collect::<HashMap<_, _>>();

        for value in namespaces.values_mut() {
            if let Some((_, new_name)) = NAMESPACE_RENAMES.iter().find(|(key, _)| key == value) {
                *value = new_name.to_string();
            }
        }
        
        BindingsGenerator {
            declaring_tys,
            krate,
            output_path: path.to_path_buf(),
            registry: Self::trace_serde_types(),
            namespaces,
            name_to_id,
            public_fields
        }.run()
    }

    /// Executes the bindings generator.
    fn run(mut self) {
        let path_to_clear = self.output_path.join("Egui");
        let _ = std::fs::remove_dir_all(path_to_clear);
        let _ = std::fs::create_dir_all(&self.output_path);

        let config = CodeGeneratorConfig::new("Egui".to_string())
            .with_serialization(true)
            .with_c_style_enums(true)
            .with_comments(self.gather_doc_comments())
            .with_namespaces(self.namespaces.clone());
        let generator = CodeGenerator::new(&config);

        self.emit_cs_fn_bindings();
        self.rename_struct_fields();
        self.remove_excluded_serialized_tys();
        
        generator.write_source_files(self.output_path, &self.registry).expect("Failed to write source files");
    }

    /// Removes types from the registry that should be excluded from the output.
    fn remove_excluded_serialized_tys(&mut self) {
        for ty in BINDING_EXCLUDE_TYPE_DEFINITIONS {
            let _ = self.registry.remove(*ty);
        }
    }

    /// Gets the C# and Rust representations of a type, or returns [`None`] if the type
    /// could not be resolved.
    fn bound_ty(&self, self_ty: Option<&str>, ty: &Type) -> Option<BoundType> {
        Some(match ty {
            Type::BorrowedRef { is_mutable, type_, .. } => {
                let inner_name = match &**type_ {
                    Type::Generic(x) if x == "Self" => self_ty,
                    Type::ResolvedPath(path) => path.path.split("::").last(),
                    _ => None
                };

                if let Some(name) = inner_name
                    && (HANDLE_TYPES.contains(&name) || POINTER_TYPES.contains(&name)) {
                    BoundType {
                        kind: BoundTypeKind::Pointer { mutable: *is_mutable },
                        name: BoundTypeName::cs_rs(name, name)
                    }
                }
                else {
                    BoundType {
                        kind: BoundTypeKind::Reference { mutable: *is_mutable },
                        name: self.bound_ty_name(self_ty, type_)?
                    }
                }
            },
            _ => BoundType {
                kind: BoundTypeKind::Value,
                name: self.bound_ty_name(self_ty, ty)?
            },
        })
    }

    /// Gets the C# and Rust names for a by-value type, or returns [`None`] if the type
    /// could not be resolved.
    fn bound_ty_name(&self, self_ty: Option<&str>, ty: &Type) -> Option<BoundTypeName> {
        Some(match ty {
            Type::ResolvedPath(path) => match path.path.as_str() {
                "Arc" | "Option" | "Vec" => {
                    let builtin_fn = match path.path.as_str() {
                        "Arc" => |x| x,
                        "Option" => |x| format!("{x}?"),
                        "Vec" => |x| format!("ReadOnlyMemory<{x}>"),
                        _ => unreachable!()
                    };

                    let Some(GenericArgs::AngleBracketed { args, .. }) = path.args.as_deref() else { return None };
                    if args.len() == 1 {
                        let GenericArg::Type(arg) = &args[0] else { return None };
                        let inner = self.bound_ty_name(self_ty, arg)?;
                        BoundTypeName::cs_rs(builtin_fn(inner.cs_name), format!("{}<{}>", path.path, inner.rs_name))
                    }
                    else {
                        return None
                    }
                },
                "String" | "str" => BoundTypeName::cs_rs("string", "String"),
                _ => {
                    let name = path.path.split("::").last().expect("Type was empty");
                    if self.registry.contains_key(name) {
                        BoundTypeName::cs_rs(name, name)
                    }
                    else {
                        return None
                    }
                }
            },
            Type::Generic(x) if x == "Self" => if HANDLE_TYPES.contains(&self_ty?) || POINTER_TYPES.contains(&self_ty?) {
                return None
            }
            else {
                BoundTypeName::cs_rs(self_ty?, self_ty?)
            },
            Type::Generic(x) if x == "IdSource" => BoundTypeName::cs_rs("Id", "Id"),
            Type::ImplTrait(x) => if x.len() == 1
                && let Some(GenericBound::TraitBound { trait_: RdPath { path, args: trait_generics, .. }, .. }) = x.first() {
                    if path == "ToString" {
                        BoundTypeName::cs_rs("string", "String")
                    }
                    else if path == "Into"
                        && let Some(GenericArgs::AngleBracketed { args, .. }) = trait_generics.as_deref()
                        && args.len() == 1
                        && let GenericArg::Type(inner_ty) = &args[0] {
                        if let Type::ResolvedPath(RdPath { path, args, .. }) = inner_ty
                            && path == "Cow"
                            && format!("{args:?}").contains("Primitive(\"str\")") {
                            BoundTypeName::cs_rs("string", "String")
                        }
                        else {
                            self.bound_ty_name(self_ty, inner_ty)?
                        }
                    }
                    else if path.contains("Hash") || path.contains("IdSource") {
                        BoundTypeName::cs_rs("Id", "Id")
                    }
                    else if path.contains("IntoAtoms") {
                        BoundTypeName::cs_rs("Atoms", "Atoms")
                    }
                    else {
                        return None
                    }
                }
                else {
                    return None
                }
            Type::Primitive(x) => BoundTypeName::cs_rs(Self::cs_primitive_name(&x)?, Self::rs_primitive_sized_name(&x)),
            Type::Tuple(items) => {
                let inner_tys = items.iter().map(|x| self.bound_ty_name(self_ty, x)).collect::<Option<Vec<_>>>()?;

                BoundTypeName::cs_rs(
                    format!("ValueTuple<{}>", inner_tys.iter().map(|x| x.cs_name.as_str()).collect::<Vec<_>>().join(", ")),
                    format!("({})", inner_tys.iter().map(|x| x.rs_name.as_str()).collect::<Vec<_>>().join(", ")))
            },
            Type::Slice(type_) => {
                let inner_ty = self.bound_ty_name(self_ty, type_)?;
                BoundTypeName::cs_rs(
                    format!("ImmutableList<{}>", inner_ty.cs_name),
                    format!("Vec<{}>", inner_ty.rs_name))
            },
            Type::Array { type_, len } => {
                let inner_ty = self.bound_ty_name(self_ty, type_)?;
                BoundTypeName::cs_rs(
                    format!("ImmutableList<{}>", inner_ty.cs_name),
                    format!("[{}; {len}]", inner_ty.rs_name))
            },
            Type::DynTrait(_)
            | Type::Generic(_)
            | Type::Pat { .. }
            | Type::Infer
            | Type::RawPointer { .. }
            | Type::QualifiedPath { .. }
            | Type::BorrowedRef { .. }
            | Type::FunctionPointer(_) => return None,
        })
    }

    /// Determines whether the type with the given name has a particular field.
    fn ty_has_field(&self, ty_name: &str, field: &str) -> bool {
        if let Some(ContainerFormat::Struct(fields)) = self.registry.get(ty_name) {
            if fields.iter().find(|x| x.name == field).is_some() {
                return !Self::field_is_private(&self.name_to_id, &self.public_fields, ty_name, field);
            }
        }

        false
    }

    /// Emits a C# file containing bindings for `egui` functions.
    fn emit_cs_fn_bindings(&self) {
        let mut result = String::new();

        result += "#pragma warning disable\n";
        result += "using System.Collections.Immutable;\n";

        let mut bound_ids = Vec::new();
        let binding_exclude_fns = BINDING_EXCLUDE_FNS.into_iter().collect::<HashSet<_>>();

        for id in self.gather_fns() {
            if binding_exclude_fns.contains(&&*self.fn_enum_variant_name(id)) {
                continue;
            }

            let result = self.emit_cs_fn_binding(&mut std::fmt::Formatter::new(&mut result, Default::default()), id);
            
            if result.is_ok() {
                bound_ids.push(id);
            }
        }
        
        self.emit_fn_enum(&bound_ids);
        std::fs::write(self.output_path.join("EguiFn.g.cs"), result).expect("Failed to write C# function bindings");
    }

    /// Writes a single C# method definition (with appropriate type qualifiers) to `f`.
    fn emit_cs_fn_binding(&self, f: &mut std::fmt::Formatter, id: RdId) -> std::fmt::Result {
        if let Some(impl_ty) = self.declaring_type(id).and_then(|x| self.krate.index.get(&x)) {
            if matches!(impl_ty.inner, ItemEnum::Struct(_)) || matches!(impl_ty.inner, ItemEnum::Enum(_)) {
                if let Some(ty_name) = impl_ty.name.as_deref() {
                    let namespace = self.namespaces.get(ty_name).cloned().unwrap_or_else(|| "Egui".to_string());
                    if HANDLE_TYPES.contains(&ty_name) {
                        let mut fn_def = String::new();
                        self.emit_cs_fn(&mut std::fmt::Formatter::new(&mut fn_def, Default::default()), Some(ty_name), id, DeclaringType::Handle)?;
                        
                        writeln!(f, "namespace {namespace} {{ public sealed partial class {ty_name} {{\n{fn_def}\n}} }}")?;
                    }
                    else if POINTER_TYPES.contains(&ty_name) {
                        let mut fn_def = String::new();
                        self.emit_cs_fn(&mut std::fmt::Formatter::new(&mut fn_def, Default::default()), Some(ty_name), id, DeclaringType::Pointer)?;
                        
                        writeln!(f, "namespace {namespace} {{ public ref partial struct {ty_name} {{\n{fn_def}\n}} }}")?;
                    }
                    else if self.registry.contains_key(ty_name) {
                        let mut fn_def = String::new();
                        let primitive_enum = self.is_primitive_enum(impl_ty.id);
                        let decl_ty = if primitive_enum { DeclaringType::PrimitiveEnum } else { DeclaringType::Struct };
                        self.emit_cs_fn(&mut std::fmt::Formatter::new(&mut fn_def, Default::default()), Some(ty_name), id, decl_ty)?;
                        
                        if primitive_enum {
                            writeln!(f, "namespace {namespace} {{ public static partial class {ty_name}Extensions {{\n{fn_def}\n}} }}")?;
                        }
                        else {
                            if Self::is_ui_fn(&self.krate.index[&id]) {
                                writeln!(f, "namespace {namespace} {{ public partial struct {ty_name} : IWidget {{\n{fn_def}\n}} }}")?;
                            }
                            else {
                                writeln!(f, "namespace {namespace} {{ public partial struct {ty_name} {{\n{fn_def}\n}} }}")?;   
                            }
                        }
                    }
                    else {
                        return Err(std::fmt::Error);
                    }

                    return Ok(());
                }
            }
        }
        else {
            let name = self.krate.index[&id].name.as_deref().unwrap_or_default();
            let namespace = self.namespaces.get(name).cloned().unwrap_or_else(|| "Egui".to_string());
            
            let short_namespace = namespace.rsplit_once(".").unwrap_or((&namespace, "")).1;
            
            let mut fn_def = String::new();

            self.emit_cs_fn(&mut std::fmt::Formatter::new(&mut fn_def, Default::default()), None, id, DeclaringType::None)?;
            
            writeln!(f, "namespace {namespace} {{ public static partial class {short_namespace}Helpers {{\n{fn_def}\n}} }}")?;
            return Ok(());
        }

        Err(std::fmt::Error)
    }

    /// Writes a single C# method definition to `f`.
    fn emit_cs_fn(&self, f: &mut std::fmt::Formatter, ty_name: Option<&str>, id: RdId, decl_ty: DeclaringType) -> std::fmt::Result {
        let item = &self.krate.index[&id];
        let ItemEnum::Function(func) = &item.inner else { panic!("Expected id to refer to a function") };

        let has_this = func.sig.inputs.first().map(|(name, _)| name == "self").unwrap_or_default();
        let returns_this = func.sig.output.as_ref().map(|x| x == &Type::Generic("Self".to_string()) || (if let Type::ResolvedPath(p) = x {
            Some(p.path.as_str()) == ty_name 
        } else { false })).unwrap_or_default();
        let original_name = item.name.as_deref().expect("Failed to get function name");
        let cs_name = if ty_name.map(|x| self.ty_has_field(x, original_name)).unwrap_or_default() {
            format!("with_{original_name}").to_case(Case::Pascal)
        }
        else {
            original_name.to_case(Case::Pascal)
        };

        let constructor = !has_this && returns_this && (cs_name == "New" || cs_name == "Default");

        if let Some(comment) = self.get_doc_comment(id) {
            writeln!(f, "/// {}", comment.replace("\n", "\n/// "))?;
        }
        else if constructor {
            writeln!(f, "/// <summary>")?;
            if cs_name == "Default" {
                writeln!(f, "/// Returns the \"default value\" for a type.")?;
                writeln!(f, "/// Default values are often some kind of initial value, identity value, or anything else that may make sense as a default.")?;
                
            }
            else {
                writeln!(f, "/// Constructs a new instance of this type.")?;
            }
            writeln!(f, "/// </summary>")?;
        }

        if constructor {
            if decl_ty != DeclaringType::Struct {
                return Err(std::fmt::Error);
            }

            write!(f, "public {}", ty_name.expect("Expected type to be provided"))?;
            self.emit_cs_fn_def(f, ty_name, id, FnType::Constructor, &func, returns_this)?;
        }
        else {
            let return_name = if let Some(bound_ty) = func.sig.output.as_ref().and_then(|x| self.bound_ty(ty_name, x)) {
                if matches!(bound_ty.kind, BoundTypeKind::Pointer { .. }) {
                    return Err(std::fmt::Error);
                }
                else {
                    bound_ty.name.cs_name
                }
            }
            else {
                "void".to_string()
            };

            let (qualifiers, fn_type) = match (has_this, decl_ty) {
                (false, DeclaringType::Handle) | (false, DeclaringType::Struct) | (false, DeclaringType::Pointer) => ("static", FnType::Static),
                (true, DeclaringType::Struct) | (true, DeclaringType::Pointer) => ("", FnType::Instance),
                (true, DeclaringType::Handle) => ("", FnType::Instance),
                (true, DeclaringType::PrimitiveEnum) => ("static", FnType::Extension),
                (_, DeclaringType::None) => ("static", FnType::Static),
                (false, DeclaringType::PrimitiveEnum) => return Err(std::fmt::Error)
            };
            
            if Self::is_ui_fn(item) {
                write!(f, "Response IWidget.Ui")?;
            }
            else {
                write!(f, "public {qualifiers} {return_name} {cs_name}")?;
            }

            self.emit_cs_fn_def(f, ty_name, id, fn_type, &func, returns_this)?;
        }

        Ok(())
    }

    /// Whether this is the [`Ui`] interface function.
    fn is_ui_fn(item: &Item) -> bool {
        if item.name.as_deref() == Some("ui")
            && let ItemEnum::Function(func) = &item.inner {
            func.sig.inputs.len() == 2 && func.sig.output.as_ref().map(|x| format!("{x:?}").contains("Response")).unwrap_or_default()
        }
        else {
            false
        }
    }

    /// Emits the body of a C# function (excluding the name and return type).
    fn emit_cs_fn_def(
        &self,
        f: &mut std::fmt::Formatter,
        ty_name: Option<&str>,
        id: RdId,
        fn_ty: FnType,
        func: &Function,
        returns_this: bool
    ) -> std::fmt::Result {
        let original_name = &self.krate.index[&id].name.as_deref().expect("Failed to get function name");
        let sig = &func.sig;

        let property = match fn_ty {
            FnType::Instance => sig.inputs.len() == 1 && sig.output.is_some() && !returns_this,
            FnType::Static => sig.inputs.is_empty() && sig.output.is_some(),
            _ => false
        } && !original_name.contains("take");
        
        if sig.output.as_ref()
            .and_then(|x| Some(!matches!(self.bound_ty(ty_name, x)?.kind, BoundTypeKind::Value | BoundTypeKind::Reference { mutable: false })))
            .unwrap_or_default() {
            return Err(std::fmt::Error);
        }

        if property {
            writeln!(f, "{{ get {{")?;
        }
        else {
            writeln!(f, "({}) {{", self.cs_binding_signature(ty_name, fn_ty, func).ok_or(std::fmt::Error)?)?;
        }

        let pointer_checks = self.cs_binding_ptr_checks(ty_name, fn_ty, func);
        writeln!(f, "    {pointer_checks}")?;

        let binding_generics = self.cs_binding_generics(ty_name, func).ok_or(std::fmt::Error)?;
        if fn_ty == FnType::Constructor {
            write!(f, "    this = ")?;
        }
        else {
            write!(f, "{}", self.cs_binding_result_decls(ty_name, func))?;

        }

        if binding_generics.is_empty() {
            writeln!(f, "EguiMarshal.Call(")?;
        }
        else {
            writeln!(f, "EguiMarshal.Call<{}>(", binding_generics)?;
        }

        let enum_name = format!("EguiFn.{}", self.fn_enum_variant_name(id));

        write!(f, "{}", [enum_name].into_iter().chain(self.cs_binding_arguments(ty_name, fn_ty, func).ok_or(std::fmt::Error)?)
            .collect::<Vec<_>>().join(", "))?;
        writeln!(f, ");")?;

        writeln!(f, "{}", self.cs_binding_result_assignments(ty_name, fn_ty, func))?;

        if sig.output.is_some() && fn_ty != FnType::Constructor {
            writeln!(f, "    return result;")?;
        }

        if property {
            writeln!(f, "}}")?;
        }

        writeln!(f, "}}")?;
        Ok(())
    }

    /// Emits a registry of all functions that have been bound.
    fn emit_fn_enum_bindings(&self, f: &mut std::fmt::Formatter, bound_ids: &[RdId]) -> std::fmt::Result {
        writeln!(f, "const AUTOGENERATED_EGUI_FNS: EguiFnMap = egui_fn_map()")?;

        for id in bound_ids {
            let ty_name = self.declaring_type(*id).and_then(|x| self.krate.index[&x].name.clone());
    
            let ItemEnum::Function(func) = &self.krate.index[id].inner else { panic!("Expected function items only") };
            
            let param_decls = self.rs_binding_signature(ty_name.as_deref(), func);
            let args = self.rs_binding_arguments(ty_name.as_deref(), func);
            let returns = self.rs_binding_returns(ty_name.as_deref(), func);

            let enum_name = self.fn_enum_variant_name(*id);
            let path = self.fn_enum_path(*id);

            let clone_return = if func.sig.output.as_ref()
                .map(|x| matches!(self.bound_ty(ty_name.as_deref(), x).expect("Failed to get return type").kind, BoundTypeKind::Reference { mutable: false })).unwrap_or_default() {
                ".to_owned()"
            }
            else {
                ""
            };

            writeln!(f, "    .with(EguiFn::{enum_name}, |{param_decls}| unsafe {{ ({path}({args}){clone_return}, {returns}) }})")?;
        }
        writeln!(f, ";")?;
        Ok(())
    }

    /// Gets the signature to use for an autobound Rust function.
    fn rs_binding_signature(&self, self_ty: Option<&str>, f: &Function) -> String {
        f.sig.inputs.iter().map(|(name, ty)| {
            let bound_ty = self.bound_ty(self_ty, ty).expect("Failed to get binding for type");
            let ty_name = match bound_ty.kind {
                BoundTypeKind::Pointer { .. } => format!("EguiPointer<{}>", bound_ty.name.rs_name),
                BoundTypeKind::Reference { .. } | BoundTypeKind::Value => bound_ty.name.rs_name.to_string(),
            };

            format!("mut {name}_: {ty_name}")
        }).collect::<Vec<_>>().join(", ")
    }
    
    /// Gets the arguments list for an autobound Rust function.
    fn rs_binding_arguments(&self, self_ty: Option<&str>, f: &Function) -> String {
        f.sig.inputs.iter().map(|(name, ty)| {
            let bound_ty = self.bound_ty(self_ty, ty).expect("Failed to get binding for type");
            match bound_ty.kind {
                BoundTypeKind::Pointer { mutable: false } => format!("{name}_.get()"),
                BoundTypeKind::Pointer { mutable: true } => format!("{name}_.get_mut()"),
                BoundTypeKind::Reference { mutable: false } => format!("&{name}_"),
                BoundTypeKind::Reference { mutable: true } => format!("&mut {name}_"),
                BoundTypeKind::Value => format!("{name}_"),
            }
        }).collect::<Vec<_>>().join(", ")
    }

    /// Gets a list of return values for an autobound function.
    fn rs_binding_returns(&self, self_ty: Option<&str>, f: &Function) -> String {
        f.sig.inputs.iter().filter(|(_, ty)| {
            let bound_ty = self.bound_ty(self_ty, ty).expect("Failed to get binding for type");
            matches!(bound_ty.kind, BoundTypeKind::Reference { mutable: true })
        }).map(|(name, _)| format!("{name}_")).collect::<Vec<_>>().join(", ")
    }

    /// Gets the signature to use for an autobound C# function.
    fn cs_binding_signature(&self, self_ty: Option<&str>, fn_ty: FnType, f: &Function) -> Option<String> {
        Some(f.sig.inputs.iter().skip(if fn_ty == FnType::Instance { 1 } else { 0 }).map(|(name, ty)| {
            let bound_ty = self.bound_ty(self_ty, ty)?;
            let ty_name = bound_ty.name.cs_name;
            let is_ref_mut = matches!(bound_ty.kind, BoundTypeKind::Reference { mutable: true });
            let ref_prefix = if is_ref_mut { "ref " } else { "" };
            Some(format!("{ref_prefix}{ty_name} {}", Self::cs_param_name(fn_ty, &name)))
        }).collect::<Option<Vec<_>>>()?.join(", "))
    }

    /// Gets the name to use for a parameter in C#.
    fn cs_param_name(fn_ty: FnType, rs_name: &str) -> String {
        if rs_name == "self" && fn_ty == FnType::Instance { "this".to_string() } else {
            match rs_name {
                "checked" => "isChecked".to_string(),
                "event" => "eventArg".to_string(),
                "new" => "newArg".to_string(),
                "this" => "thisArg".to_string(),
                _ => rs_name.to_case(Case::Camel)
            }
        }
    }

    /// Gets the signature to use for an autobound C# function.
    fn cs_binding_ptr_checks(&self, self_ty: Option<&str>, fn_ty: FnType, f: &Function) -> String {
        f.sig.inputs.iter().skip(if fn_ty == FnType::Instance { 1 } else { 0 })
            .filter(|(_, ty)| matches!(self.bound_ty(self_ty, ty).expect("Failed to get parameter type").kind, BoundTypeKind::Pointer { .. }))
            .map(|(name, _)| {
                let cs_name = Self::cs_param_name(fn_ty, &name);
                format!("if({cs_name}.Ptr == 0) {{ throw new NullReferenceException(\"{cs_name} was null\"); }}")
            })
            .collect::<Vec<_>>().join("\n    ")
    }

    /// Gets the call generics to use for an autobound C# function.
    fn cs_binding_generics(&self, self_ty: Option<&str>, f: &Function) -> Option<String> {
        let mut outputs = Vec::new();

        if let Some(x) = &f.sig.output {
            let bound_ty = self.bound_ty(self_ty, x)?;
            if matches!(bound_ty.kind, BoundTypeKind::Reference { mutable: true } | BoundTypeKind::Pointer { .. }) {
                return None;
            }

            outputs.push(bound_ty.name.cs_name);
        }

        let mut generics = f.sig.inputs.iter().map(|(_, ty)| {
            let bound_ty = self.bound_ty(self_ty, ty)?;
            let ty_name = match bound_ty.kind {
                BoundTypeKind::Pointer { .. } => "nuint",
                BoundTypeKind::Reference { .. } | BoundTypeKind::Value => bound_ty.name.cs_name.as_str(),
            };

            if matches!(bound_ty.kind, BoundTypeKind::Reference { mutable: true }) {
                outputs.push(bound_ty.name.cs_name.clone());
            }

            Some(format!("{ty_name}"))
        }).collect::<Option<Vec<_>>>()?;

        match outputs.len() {
            0 => {},
            1 => generics.push(outputs[0].clone()),
            _ => generics.push(format!("({})", outputs.join(",")))
        }
        
        Some(generics.join(", "))
    }
    
    /// Gets the arguments list for an autobound C# function.
    fn cs_binding_arguments(&self, self_ty: Option<&str>, fn_ty: FnType, f: &Function) -> Option<Vec<String>> {
        f.sig.inputs.iter().map(|(name, ty)| {
            let cs_name = Self::cs_param_name(fn_ty, &name);

            Some(match self.bound_ty(self_ty, ty)?.kind {
                BoundTypeKind::Pointer { .. } => format!("{cs_name}.Ptr"),
                BoundTypeKind::Reference { .. } | BoundTypeKind::Value => format!("{cs_name}"),
            })
        }).collect::<Option<Vec<_>>>()
    }
    
    /// Gets the result declarations list for an autobound C# function.
    fn cs_binding_result_decls(&self, self_ty: Option<&str>, f: &Function) -> String {
        let mut vars = Vec::new();

        if f.sig.output.is_some() {
            vars.push("result".to_string());
        }

        vars.extend(f.sig.inputs.iter().filter_map(|(name, ty)|
            matches!(self.bound_ty(self_ty, ty).expect("Failed to resolve result declaration").kind, BoundTypeKind::Reference { mutable: true })
                .then(|| format!("{name}_result").to_case(Case::Camel)))
            .collect::<Vec<String>>());

        match vars.len() {
            0 => String::new(),
            1 => format!("var {} = ", vars[0]),
            _ => format!("var ({}) =", vars.join(", "))
        }
    }
    
    /// Gets the result declarations list for an autobound C# function.
    fn cs_binding_result_assignments(&self, self_ty: Option<&str>, fn_ty: FnType, f: &Function) -> String {
        f.sig.inputs.iter().filter_map(|(name, ty)|
            matches!(self.bound_ty(self_ty, ty).expect("Failed to resolve result declaration").kind, BoundTypeKind::Reference { mutable: true })
                .then(|| format!("{} = {};", Self::cs_param_name(fn_ty, &name),
                    format!("{name}_result").to_case(Case::Camel))))
            .collect::<Vec<String>>().join("\n    ")
    }

    /// Emits an `enum` containing the names of all public `egui` functions.
    fn emit_fn_enum(&self, bound_ids: &[RdId]) {
        let variants = self.fn_enum_variant_names();
        let mut result = String::new();
        
        result += "#[allow(warnings)]\n";
        result += "#[derive(Clone, Copy, Debug)]\n";
        result += "#[repr(C)]\n";
        result += "pub enum EguiFn {\n    ";
        result += &variants.join(",\n    ").trim();
        result += "}\n";

        result += "impl EguiFn {\n";
        result += "    /// All enum variants.\n";
        result += "    pub const ALL: &[Self] = &[\n    ";
        result += &variants.iter().map(|x| "Self::".to_string() + x).collect::<Vec<_>>().join(",\n    ").trim();
        result += "    ];\n";
        result += "}\n";

        self.emit_fn_enum_bindings(&mut std::fmt::Formatter::new(&mut result, Default::default()), bound_ids)
            .expect("Failed to emit function enum bindings");

        std::fs::write(self.output_path.join("egui_fn.rs"), result).expect("Failed to write egui function enum");
    }

    /// Gets the variant names for an `enum` containing all public `egui` functions.
    fn fn_enum_variant_names(&self) -> Vec<String> {
        let mut result = self.gather_fns().into_iter().map(|id| self.fn_enum_variant_name(id)).collect::<Vec<_>>();
        result.extend(CUSTOM_FNS.into_iter().map(|x| x.to_string()));
        result.sort();
        result
    }

    /// Gets the `EguiFn` variant name of `id`.
    fn fn_enum_variant_name(&self, id: RdId) -> String {
        if let Some(impl_ty) = self.declaring_type(id) {
            format!("{}_{}", self.krate.paths[&impl_ty].path.join("_"), self.krate.index[&id].name.clone().unwrap_or_default())
        }
        else if self.krate.paths.contains_key(&id) {
            format!("{}", self.krate.paths[&id].path.join("_"))
        }
        else {
            panic!("Item was not a bindable egui function")
        }
    }

    /// Gets the Rust path of a function with `id`.
    fn fn_enum_path(&self, id: RdId) -> String {
        if let Some(impl_ty) = self.declaring_type(id) {
            format!("{}::{}", self.krate.paths[&impl_ty].path.last().expect("Couldn't find type name"), self.krate.index[&id].name.clone().unwrap_or_default())
        }
        else if self.krate.paths.contains_key(&id) {
            self.krate.index[&id].name.clone().unwrap_or_default()
        }
        else {
            panic!("Item was not a bindable egui function")
        }
    }

    /// Gets all doc-comments to emit for types and fields.
    fn gather_doc_comments(&self) -> DocComments {
        let mut result = DocComments::default();
        for name in self.registry.keys() {
            if let Some(id) = self.get_type_id(name) {
                if let Some(docs) = self.get_doc_comment(id) {
                    result.insert(vec!["Egui".to_string(), name.clone()], docs);
                }

                let fields = match &self.krate.index[&id].inner {
                    ItemEnum::Struct(Struct { kind: StructKind::Plain { fields, .. }, .. }) => &**fields,
                    ItemEnum::Enum(Enum { variants, .. }) => &**variants,
                    _ => &[]
                };

                for field in fields {
                    let field_name = self.krate.index[field].name.clone().unwrap_or_default();
                    if let Some(docs) = self.get_doc_comment(*field) {
                        result.insert(vec!["Egui".to_string(), name.clone(), field_name.to_case(Case::Pascal)], docs);
                    }
                }
            }
        }
        result
    }

    /// Gets a list of all functions that should be bound for `egui`.
    fn gather_fns(&self) -> Vec<RdId> {
        let ignore_fns = IGNORE_FNS.into_iter().collect::<HashSet<_>>();

        self.krate.index.iter()
            .filter_map(|(id, item)| (
                item.crate_id == 0
                && item.deprecation.is_none()
                && if let Some(decl_ty) = self.declaring_type(*id) {
                    !(item.name.as_deref() == Some("default") && self.is_primitive_enum(decl_ty))
                }
                else {
                    self.krate.paths.contains_key(id)
                }
                && matches!(item.inner, ItemEnum::Function(_))
                && {
                    let variant_name = self.fn_enum_variant_name(*id);
                    variant_name.starts_with("e") &&!ignore_fns.contains(&&*variant_name) && !variant_name.contains("___deserialize___")
                }
                && item.name.as_deref().map(|x| !IGNORE_FN_NAMES.contains(&x)).unwrap_or(true)
            ).then_some(id.clone()))
            .collect()
    }

    /// Gets the ID of the type that declares the given function.
    fn declaring_type(&self, fn_id: RdId) -> Option<RdId> {
        self.declaring_tys.get(&fn_id).cloned()
    }
    
    /// Checks if the enum only has primitive variants.
    fn is_primitive_enum(&self, id: RdId) -> bool {
        let ItemEnum::Enum(x) = &self.krate.index[&id].inner else { return false };
        for variant in &x.variants {
            let ItemEnum::Variant(x) = &self.krate.index[variant].inner else { unreachable!() };
            if x.kind != VariantKind::Plain {
                return false;
            }
        }
    
        true
    }

    /// Renames all fields in the registry from Rust to C# casing.
    fn rename_struct_fields(&mut self) {
        for (ty_name, item) in &mut self.registry {
            match item {
                ContainerFormat::Struct(nameds) => for field in nameds {
                    if Self::field_is_private(&self.name_to_id, &self.public_fields, &ty_name, &field.name) {
                        field.name = format!("_{}", field.name.to_case(Case::Camel));
                    }
                    else {
                        field.name = field.name.to_case(Case::Pascal);
                    }
                },
                ContainerFormat::Enum(variants) => for variant in variants.values_mut() {
                    variant.name = variant.name.to_case(Case::Pascal);
                },
                _ => {},
            }
        }
    }
    
    /// Gets the C# doc-comment to use for an item given its ID.
    fn get_doc_comment(&self, id: RdId) -> Option<String> {
        let docs = self.krate.index[&id].docs.clone().unwrap_or_default();
        let converted_docs = Self::inline_code_to_cs(&Self::strip_links(&Self::strip_code_comments(docs.trim_end())))
            .replace("\n\n", "<br/>\n\n");
        if converted_docs.is_empty() {
            None
        }
        else {
            Some(format!("<summary>\n{converted_docs}\n</summary>"))
        }
    }
    
    /// Gets the `rustdoc` ID for a type given its name.
    fn get_type_id(&self, name: &str) -> Option<RdId> {
        self.name_to_id.get(name).cloned()
    }

    /// Computes a mapping from IDs to declaring types.
    fn declaring_types(krate: &Crate) -> HashMap<RdId, RdId> {
        let mut result = HashMap::new();

        for parent in krate.index.values() {
            if let ItemEnum::Impl(Impl { for_: Type::ResolvedPath(p), items, .. }) = &parent.inner {
                for child in items {
                    result.insert(*child, p.id);
                }
            }
        }

        result
    }

    /// Computes a mapping from names to type IDs.
    fn names_to_ids(krate: &Crate) -> HashMap<String, RdId> {
        let mut result = HashMap::new();

        for (item_id, item) in &krate.index {
            if matches!(item.inner, ItemEnum::Enum(_) | ItemEnum::Struct(_)) {
                if let Some(name) = &item.name {
                    result.insert(name.clone(), *item_id);
                }
            }
        }

        result
    }

    /// Performs reflection on `egui` types to determine fields.
    fn trace_serde_types() -> Registry {
        let mut samples = Samples::new();
        let mut tracer = Tracer::new(TracerConfig::default()
            .default_u64_value(1)
            .record_samples_for_newtype_structs(true)
            .record_samples_for_tuple_structs(true)
            .record_samples_for_structs(true));


        tracer.trace_value(&mut samples, &Options::default()).expect("Failed to trace Options");
        
        tracer.trace_type::<AlphaFromCoverage>(&samples).expect("Failed to trace AlphaFromCoverage");
        tracer.trace_type::<TextureId>(&samples).expect("Failed to trace AlphaFromCoverage");
        tracer.trace_simple_type::<Align>().expect("Failed to trace Align");
        tracer.trace_simple_type::<FontFamily>().expect("Failed to trace FontFamily");
        tracer.trace_simple_type::<TextWrapMode>().expect("Failed to trace TextWrapMode");
        tracer.trace_simple_type::<PinchType>().expect("Failed to trace PinchType");
        tracer.trace_simple_type::<PointerEvent>().expect("Failed to trace PointerEvent");
        tracer.trace_simple_type::<ProgressBarText>().expect("Failed to trace ProgressBarText");
        tracer.trace_simple_type::<SidesKind>().expect("Failed to trace SidesKind");
        
        trace_auto_egui_types(&mut tracer);
        trace_auto_emath_types(&mut tracer);
        trace_auto_epaint_types(&mut tracer);
        trace_auto_ecolor_types(&mut tracer);

        let mut result = tracer.registry().expect("Failed to generate serde registry");

        for ty in BINDING_EXCLUDE_TYPES {
            let _ = result.remove(*ty);
        }

        result
    }

    /// Removes all code examples from the given documentation string.
    fn strip_code_comments(docs: &str) -> String {
        let mut result = Cow::Borrowed(docs);
        while let Some(index) = result.find("```") {
            let base_offset = index + "```".len();
            if let Some(remaining) = result[base_offset..].find("```") {
                result = Cow::Owned(result[..index].trim_end().to_owned() + result[base_offset + remaining + "```".len()..].trim_start());
            }
            else {
                break;
            }
        }
        
        result.trim().to_string()
    }

    /// Removes all links from the given documentation string.
    fn strip_links(docs: &str) -> String {
        let mut result = Cow::Borrowed(docs);
        while let Some(index) = result.find("[") {
            let base_offset = index + "[".len();
            if let Some(remaining) = result[base_offset..].find("]") {
                let inner_text = result[base_offset..base_offset + remaining].to_string();
                let rest_begin = base_offset + remaining + "]".len();
                let final_offset = if result[rest_begin..].starts_with("(") {
                    rest_begin + result[rest_begin..].find(")").expect("Malformatted documentation link") + ")".len()
                }
                else {
                    rest_begin
                };

                result = Cow::Owned(result[..index].to_owned() + &inner_text + &result[final_offset..]);
            }
            else {
                break;
            }
        }
        
        result.trim().to_string()
    }

    /// Removes everything before the last instance of `ending` in `value`.
    fn strip_prefix_with_ending(value: &str, ending: &str) -> String {
        let mut start_pos = 0;
        while let Some(prefix) = value[start_pos..].find(ending) {
            start_pos = start_pos + prefix + ending.len();
        }
        value[start_pos..].to_string()
    }

    /// Converts all inline code snippets to their C# equivalent.
    fn inline_code_to_cs(docs: &str) -> String {
        let mut result = Cow::Borrowed(docs);
        while let Some(index) = result.find("`") {
            let base_offset = index + "`".len();
            if let Some(remaining) = result[base_offset..].find("`") {
                let end_offset = base_offset + remaining + "`".len();

                result = Cow::Owned(result[..index].to_owned()
                    + "<c>" + &Self::strip_prefix_with_ending(&result[base_offset..base_offset + remaining], "::").to_case(Case::Pascal) + "</c>"
                    + &result[end_offset..]);
            }
            else {
                break;
            }
        }
        
        result.trim().to_string()
    }

    /// Converts the given Rust primitive to a C# primitive, or returns
    /// [`None`] if the primitive was not recognized.
    fn cs_primitive_name(x: &str) -> Option<&'static str> {
        Some(match x {
            "bool" => "bool",
            "char" => "char",
            "str" => "string",
            "u8" => "byte",
            "u16" => "ushort",
            "u32" => "uint",
            "u64" => "ulong",
            "i8" => "sbyte",
            "i16" => "short",
            "i32" => "int",
            "i64" => "long",
            "f32" => "float",
            "f64" => "double",
            "isize" => "nint",
            "usize" => "nuint",
            _ => return None
        })
    }

    /// Converts the given Rust primitive (porentially unsized) to a sized primitive.
    fn rs_primitive_sized_name(x: &str) -> &str {
        match x {
            "str" => "String",
            x => x
        }
    }

    /// Gathers the public paths of all types that are exported from all crates.
    fn find_public_paths(krate: &Crate, crate_names: &[&str]) -> HashMap<String, Vec<String>> {
        let mut result = HashMap::new();

        for crate_name in crate_names {
            for (item_id, item) in &krate.index {
                if let ItemEnum::Module(module) = &item.inner {
                    if module.is_crate && item.name.as_deref() == Some(crate_name) {
                        for (name, mut path) in Self::find_public_paths_for_module(krate, *item_id) {
                            path.insert(0, crate_name.to_string());
                            if !result.contains_key(&name) {
                                result.insert(name, path);
                            }
                        }
                    }
                }
            }
        }

        result
    }

    /// Gathers the public paths of all types that are exported from the given module.
    fn find_public_paths_for_module(krate: &Crate, id: RdId) -> HashMap<String, Vec<String>> {
        let ItemEnum::Module(module) = &krate.index[&id].inner else { panic!("Item was not module") };

        let mut result = HashMap::new();
        for item_id in &module.items {
            let item = &krate.index[item_id];
            let item_name = item.name.as_deref().unwrap_or_default();

            match &item.inner {
                ItemEnum::Module(_) => {
                    for (name, mut path) in Self::find_public_paths_for_module(krate, *item_id) {
                        path.insert(0, item_name.to_string());
                        if !result.contains_key(&name) {
                            result.insert(name, path);
                        }
                    }
                },
                ItemEnum::Function(_) => { result.insert(item_name.to_string(), vec![item_name.to_string()]); }
                ItemEnum::Struct(_) | ItemEnum::Enum(_) => { result.insert(item_name.to_string(), vec![item_name.to_string()]); },
                ItemEnum::Use(use_decl) => if use_decl.is_glob {
                    if let Some(glob_id) = use_decl.id {
                        for (name, path) in Self::find_public_paths_for_module(krate, glob_id) {
                            if !result.contains_key(&name) {
                                result.insert(name, path);
                            }
                        }
                    }
                } else {
                    result.insert(use_decl.name.clone(), vec![use_decl.name.clone()]);
                },
                ItemEnum::Union(_)
                | ItemEnum::Primitive(_)
                | ItemEnum::ProcMacro(_)
                | ItemEnum::Macro(_)
                | ItemEnum::ExternType
                | ItemEnum::Static(_)
                | ItemEnum::Constant { .. }
                | ItemEnum::Trait(_)
                | ItemEnum::TraitAlias(_)
                | ItemEnum::Variant(_)
                | ItemEnum::StructField(_)
                | ItemEnum::AssocConst { .. }
                | ItemEnum::ExternCrate { .. }
                | ItemEnum::AssocType { .. } 
                | ItemEnum::Impl(_)
                | ItemEnum::TypeAlias(_) => {},
            }
        }

        result
    }

    /// Combines two crate documentation objects into one.
    fn merge_crates(target: &mut Crate, source: &Crate) {
        assert!(!target.includes_private);
        assert!(!source.includes_private);

        let mut remapper = CrateIdRemapper::new(target);

        for (old_id, item) in source.index.iter().map(|(a, b)| (*a, b.clone())) {
            let new_id = remapper.map(old_id);
            target.index.insert(new_id, Item {
                id: new_id,
                links: item.links.into_iter().map(|(k, v)| (k, remapper.map(v))).collect(),
                inner: match item.inner {
                    ItemEnum::Module(module) => ItemEnum::Module(Module {
                        is_crate: module.is_crate,
                        items: module.items.into_iter().map(|x| remapper.map(x)).collect(),
                        is_stripped: module.is_stripped
                    }),
                    ItemEnum::Enum(x) => ItemEnum::Enum(Enum {
                        variants: x.variants.into_iter().map(|x| remapper.map(x)).collect(),
                        ..x
                    }),
                    ItemEnum::Struct(x) => ItemEnum::Struct(Struct {
                        kind: match x.kind {
                            StructKind::Unit => StructKind::Unit,
                            StructKind::Tuple(ids) => StructKind::Tuple(ids.into_iter().map(|x| x.map(|y| remapper.map(y))).collect()),
                            StructKind::Plain { fields, has_stripped_fields } => StructKind::Plain { fields: fields.into_iter().map(|x| remapper.map(x)).collect(), has_stripped_fields },
                        },
                        ..x
                    }),
                    ItemEnum::Function(function) => ItemEnum::Function(Function {
                        sig: FunctionSignature {
                            inputs: function.sig.inputs.into_iter().map(|(k, v)| (k, remapper.map_type(v))).collect(),
                            output: function.sig.output.map(|x| remapper.map_type(x)),
                            is_c_variadic: function.sig.is_c_variadic
                        },
                        ..function
                    }),
                    ItemEnum::Impl(x) => ItemEnum::Impl(Impl {
                        for_: remapper.map_type(x.for_),
                        trait_: x.trait_.map(|x| RdPath { id: remapper.map(x.id), ..x }),
                        items: x.items.iter().map(|x| remapper.map(*x)).collect(),
                        ..x
                    }),
                    ItemEnum::Use(x) => ItemEnum::Use(Use {
                        id: x.id.map(|y| remapper.map(y)),
                        ..x
                    }),
                    x => x
                },
                ..item
            });
        }

        for (old_id, path) in source.paths.iter().map(|(a, b)| (*a, b.clone())) {
            let new_id = remapper.map(old_id);
            target.paths.insert(new_id, path);
        }
    }

    /// Determines whether a field is private.
    fn field_is_private(ty_set: &HashMap<String, RdId>, name_set: &HashSet<(String, String)>, ty_name: &str, field_name: &str) -> bool {
        ty_set.contains_key(ty_name) && !name_set.contains(&(ty_name.to_string(), field_name.to_string()))
    }

    fn public_fields(krate: &Crate) -> HashSet<(String, String)> {
        let mut result = HashSet::new();

        for item in krate.index.values() {
            if let ItemEnum::Struct(Struct { kind: StructKind::Plain { fields, .. }, .. }) = &item.inner {
                let Some(ty_name) = item.name.as_deref() else { continue };
                
                for field_id in fields {
                    let field = &krate.index[field_id];
                    if let Some(field_name) = &field.name {
                        result.insert((ty_name.to_string(), field_name.to_string()));
                    }
                }
            }
            
        }

        result
    }
}

/// Describes the type that declares a function.
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
enum DeclaringType {
    /// The type is a primitive C-style enum.
    PrimitiveEnum,
    /// The type is a pass-by-value `struct`.
    Struct,
    /// The type is a garbage-collected `class`.
    Handle,
    /// The type is a `ref struct`.`
    Pointer,
    /// The type will be a static helper class.
    None
}

/// How to emit a particular function.
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
enum FnType {
    /// The function should be treated as a constructor.
    Constructor,
    /// The function should be treated as an instance extension method.
    Extension,
    /// The function should be treated as an instance method.
    Instance,
    /// The function should be treated as a static method.
    Static
}

/// Facilitates assigning new IDs to items.
struct CrateIdRemapper {
    /// The next available ID.
    next_id: u32,
    /// A map from old IDs to new IDs.
    remappings: HashMap<RdId, RdId>
}

impl CrateIdRemapper {
    /// Creates a new remapper.
    pub fn new(target: &Crate) -> Self {
        let next_id = target.index.keys().map(|x| x.0).max().unwrap_or_default() + 1;
        Self {
            next_id,
            remappings: HashMap::default()
        }
    }

    /// Maps an old ID to a new ID.
    pub fn map(&mut self, id: RdId) -> RdId {
        *self.remappings.entry(id).or_insert_with(|| {
            let result = Id(self.next_id);
            self.next_id += 1;
            result
        })
    }

    /// Maps all relevant IDs within `ty` to new ones.
    pub fn map_type(&mut self, ty: Type) -> Type {
        match ty {
            Type::ResolvedPath(path) => Type::ResolvedPath(RdPath {
                id: self.map(path.id),
                ..path
            }),
            x => x,
        }
    }
}

/// Specifies the name of a type in C# and Rust.
#[derive(Clone, Debug)]
struct BoundTypeName {
    /// The name of the type to use in C#.
    pub cs_name: String,
    /// The name of the type to use in Rust.
    pub rs_name: String
}

impl BoundTypeName {
    /// Defines a type name in C# and Rust.
    pub fn cs_rs(cs_name: impl Into<String>, rs_name: impl Into<String>) -> Self {
        Self {
            cs_name: cs_name.into(),
            rs_name: rs_name.into()
        }
    }
}

/// Describes the type of a parameter or return value from a function.
#[derive(Clone, Debug)]
struct BoundType {
    /// How the type is used.
    kind: BoundTypeKind,
    /// The name of the type in C# and Rust.
    name: BoundTypeName
}

/// The semantics of passing a bound type between C# and Rust.
#[derive(Copy, Clone, Debug)]
enum BoundTypeKind {
    /// The type should be treated as a pointer, and deserialized as a memory address.
    Pointer {
        /// Whether the pointer is mutable.
        mutable: bool,
    },
    /// During function calls, the type should be deserialized and then passed by reference.
    Reference {
        /// Whether the reference is mtuable.
        mutable: bool,
    },
    /// During function calls, the type should be deserialized and then passed by value.
    Value
}