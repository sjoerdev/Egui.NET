#![allow(warnings)]

#![feature(fn_traits)]
#![feature(thread_local)]
#![feature(tuple_trait)]
#![feature(unboxed_closures)]

use egui::*;
use egui::color_picker::*;
use egui::ecolor::*;
use egui::emath::*;
use egui::emath::align::*;
use egui::emath::easing::*;
use egui::emath::smart_aim::*;
use egui::epaint::*;
use egui::epaint::tessellator::*;
use egui::epaint::text::*;
use egui::epaint::text::cursor::*;
use egui::epaint::textures::*;
use egui::Id;
use egui::collapsing_header::*;
use egui::containers::*;
use egui::containers::menu::*;
use egui::containers::menu::SubMenu;
use egui::gui_zoom::*;
use egui::introspection::*;
use egui::layers::*;
use egui::load::*;
use egui::os::*;
use egui::output::*;
use egui::panel::*;
use egui::scroll_area::*;
use egui::style::*;
use egui::text::*;
use egui::text_edit::*;
use egui::text_selection::*;
use egui::text_selection::text_cursor_state::*;
use egui::text_selection::visuals::*;
use egui::util::undoer::*;
use serde::*;
use serde::de::*;
use std::borrow::*;
use std::collections::*;
use std::ffi::*;
use std::marker::PhantomData;
use std::marker::Tuple;
use std::mem::*;
use std::ops::*;
use std::sync::atomic::AtomicUsize;
use std::time::*;
use std::panic;
use std::panic::catch_unwind;
use std::sync::*;

/// The global memory allocator to use.
#[global_allocator]
static GLOBAL: mimalloc::MiMalloc = mimalloc::MiMalloc;

include!(concat!(env!("CARGO_MANIFEST_DIR"), "/../target/bindings/egui_fn.rs"));

/// A registry containing all `egui` functions callable from C#.
const EGUI_FNS: EguiFnMap = AUTOGENERATED_EGUI_FNS
    // Bindings for Area
    .with(EguiFn::egui_containers_area_Area_show, |ctx: EguiPointer<Context>, area: Area, callback: EguiCallback| unsafe { area.show(ctx.get(), |ui| callback.invoke(ui as *const _ as *const _)).response })
    // Bindings for AreaState
    .with(EguiFn::egui_containers_area_AreaState_load, |ctx: EguiPointer<Context>, id: Id| unsafe { AreaState::load(ctx.get(), id) })
    // Bindings fot Atoms
    .with(EguiFn::egui_atomics_atoms_Atoms_text, |atoms: Atoms| atoms.text().map(|x| x.into_owned()))
    // Bindings for BytesLoader
    //.with(EguiFn::egui_load_BytesLoaderData_uri, |data: EguiPointer<EguiBytesLoaderData>| unsafe { data.get().uri.to_string() })
    //.with(EguiFn::egui_load_BytesLoaderData_set_result, |mut data: EguiPointer<EguiBytesLoaderData>, result: BytesPoll| unsafe { data.get_mut().result = Some(result) })
    // Bindings for CentralPanel
    .with(EguiFn::egui_containers_panel_CentralPanel_show, |ctx: EguiPointer<Context>, panel: CentralPanel, callback: EguiCallback| unsafe {
        panel.show(ctx.get(), |ui| {
            callback.invoke(ui as *const _ as *const _);
        }).response
    })
    .with(EguiFn::egui_containers_panel_CentralPanel_show_inside, |mut ui: EguiPointer<Ui>, panel: CentralPanel, callback: EguiCallback| unsafe {
        panel.show_inside(ui.get_mut(), |ui| {
            callback.invoke(ui as *const _ as *const _);
        }).response
    })
    // Bindings for Checkbox
    .with(EguiFn::egui_widgets_checkbox_Checkbox_ui, |mut ui: EguiPointer<Ui>, atoms: Atoms, mut checked: bool, indeterminate: bool| unsafe { (ui.get_mut().add(Checkbox::new(&mut checked, atoms).indeterminate(indeterminate)), checked) })
    // Bindings for CollapsingHeader
    .with(EguiFn::egui_containers_collapsing_header_CollapsingHeader_show, |mut ui: EguiPointer<Ui>, obj: CollapsingHeader, callback: EguiCallback| unsafe {
        let result = obj.show(ui.get_mut(), |ui| callback.invoke(ui as *const _ as *const _));
        (result.header_response, result.body_response, result.openness)
    })
    .with(EguiFn::egui_containers_collapsing_header_CollapsingHeader_show_unindented, |mut ui: EguiPointer<Ui>, obj: CollapsingHeader, callback: EguiCallback| unsafe {
        let result = obj.show_unindented(ui.get_mut(), |ui| callback.invoke(ui as *const _ as *const _));
        (result.header_response, result.body_response, result.openness)
    })
    // Bindings for CollapsingState
   .with(EguiFn::egui_containers_collapsing_header_CollapsingState_show_body_indented, |mut state: CollapsingState, header_response: Response, mut ui: EguiPointer<Ui>, callback: EguiCallback| unsafe {
        (state.show_body_indented(&header_response, ui.get_mut(), |ui| callback.invoke(ui as *const _ as *const _)).map(|x| x.response), state)
    })    
   .with(EguiFn::egui_containers_collapsing_header_CollapsingState_show_body_unindented, |mut state: CollapsingState, mut ui: EguiPointer<Ui>, callback: EguiCallback| unsafe {
        (state.show_body_unindented(ui.get_mut(), |ui| callback.invoke(ui as *const _ as *const _)).map(|x| x.response), state)
    })
    // Bindings for Color32
    .with(EguiFn::ecolor_color32_Color32_from_hex, |x: String| Color32::from_hex(&x).ok())
    // Bindings for Context
    .with(EguiFn::egui_context_Context_default, || EguiHandle::to_heap(Context::default()))
    .with(EguiFn::egui_context_Context_ref_id, |ctx: EguiPointer<Context>| unsafe { *transmute::<_, &usize>(ctx.get()) })
    .with(EguiFn::egui_context_Context_ref_count, |ctx: EguiPointer<Context>| unsafe { transmute::<_, &&AtomicUsize>(ctx.get()).load(atomic::Ordering::SeqCst) })
    .with(EguiFn::egui_context_Context_ref_decrement, |ctx: EguiPointer<Context>| unsafe { (ctx.get() as *const Context).read(); })
    .with(EguiFn::egui_context_Context_request_discard, |ctx: EguiPointer<Context>, x: String| unsafe { ctx.get().request_discard(x) })
    //.with(EguiFn::egui_context_Context_add_bytes_loader, |ctx: EguiPointer<Context>, name: String, id: usize, loader_index: usize, implementation: EguiPointer<EguiBytesLoaderImpl>| unsafe { ctx.get().add_bytes_loader(Arc::new(EguiWrappedBytesLoader { id, loader_index, name, implementation: *implementation.get() })); })
    .with(EguiFn::egui_context_Context_layer_painter, |ctx: EguiPointer<Context>, layer_id: LayerId| unsafe { EguiHandle::to_heap(ctx.get().layer_painter(layer_id)) })
    .with(EguiFn::egui_context_Context_debug_painter, |ctx: EguiPointer<Context>| unsafe { EguiHandle::to_heap(ctx.get().debug_painter()) })
    .with(EguiFn::egui_context_Context_input, |ctx: EguiPointer<Context>| unsafe { ctx.get().input(|i| i.clone()) })
    .with(EguiFn::egui_context_Context_input_mut, |ctx: EguiPointer<Context>, state: InputState| unsafe { ctx.get().input_mut(|i| *i = state) })
    .with(EguiFn::egui_context_Context_tessellation_options, |ctx: EguiPointer<Context>| unsafe { ctx.get().tessellation_options(|i| i.clone()) })
    .with(EguiFn::egui_context_Context_tessellation_options_mut, |ctx: EguiPointer<Context>, opts: TessellationOptions| unsafe { ctx.get().tessellation_options_mut(|i| *i = opts) })
    .with(EguiFn::egui_context_Context_graphics, |ctx: EguiPointer<Context>| unsafe { ctx.get().graphics(|i| i.clone()) })
    .with(EguiFn::egui_context_Context_graphics_mut, |ctx: EguiPointer<Context>, state: GraphicLayers| unsafe { ctx.get().graphics_mut(|i| *i = state) })
    .with(EguiFn::egui_context_Context_input_for, |ctx: EguiPointer<Context>, id: ViewportId| unsafe { ctx.get().input_for(id, |i| i.clone()) })
    .with(EguiFn::egui_context_Context_input_mut_for, |ctx: EguiPointer<Context>, id: ViewportId, state: InputState| unsafe { ctx.get().input_mut_for(id, |i| *i = state) })
    .with(EguiFn::egui_context_Context_output, |ctx: EguiPointer<Context>| unsafe { ctx.get().output(|i| i.clone()) })
    .with(EguiFn::egui_context_Context_output_mut, |ctx: EguiPointer<Context>, state: PlatformOutput| unsafe { ctx.get().output_mut(|i| *i = state) })
    .with(EguiFn::egui_context_Context_load_texture, |ctx: EguiPointer<Context>, name: String, image: ImageData, options: TextureOptions| unsafe { EguiHandle::to_heap(ctx.get().load_texture(name, image, options)) })
    .with(EguiFn::egui_context_Context_memory, |ctx: EguiPointer<Context>, callback: EguiCallback| unsafe { ctx.get().memory(|i| {
        let mut cloned = i.clone();
        callback.invoke(&mut cloned as *const _ as *const _);
    }) })
    .with(EguiFn::egui_context_Context_memory_mut, |ctx: EguiPointer<Context>, callback: EguiCallback| unsafe { ctx.get().memory_mut(|i| callback.invoke(i as *const _ as *const _)) })
    .with(EguiFn::egui_context_Context_run, |ctx: EguiPointer<Context>, raw_input: RawInput, callback: EguiCallback| unsafe {
        ctx.get().run(raw_input, |ctx| {
            callback.invoke(std::ptr::null());
        })
    })
    .with(EguiFn::egui_context_Context_fonts, |ctx: EguiPointer<Context>, callback: EguiCallback| unsafe {
        ctx.get().fonts(|fonts| callback.invoke(fonts as *const _ as *const _))
    })
    // Bindings for ComboBox
    .with(EguiFn::egui_containers_combo_box_ComboBox_show_ui, |mut ui: EguiPointer<Ui>, obj: ComboBox, callback: EguiCallback| unsafe { obj.show_ui(ui.get_mut(), |ui| callback.invoke(ui as *const _ as *const _)).response })
    // Bindings for DragValue
    .with(EguiFn::egui_widgets_drag_value_DragValue_ui, |mut ui: EguiPointer<Ui>, obj: SerializableDragValue, mut value: f64| unsafe {
        (ui.get_mut().add(obj.to_drag_value(&mut value)), value)
    })
    // Bindings for ecolor
    .with(EguiFn::ecolor_hsva_hsv_from_rgb, |rgb: [f32; 3]| hsv_from_rgb(rgb))
    .with(EguiFn::ecolor_hsva_rgb_from_hsv, |hsv: (f32, f32, f32)| rgb_from_hsv(hsv))
    // Bindings for epaint
    .with(EguiFn::epaint_shape_transform_adjust_colors, |mut shape: Shape, callback: EguiCallback| unsafe {
        shape_transform::adjust_colors(&mut shape, move |color| callback.invoke(color as *const _ as *const _));
        shape
    })
    .with(EguiFn::epaint_text_fonts_FontDefinitions_builtin_font_names, || FontDefinitions::builtin_font_names().into_iter().map(ToString::to_string).collect::<Vec<_>>())
    // Bindings for Frame
    .with(EguiFn::egui_containers_frame_Frame_show, |mut ui: EguiPointer<Ui>, frame: Frame, callback: EguiCallback| unsafe { frame.show(ui.get_mut(), |ui| callback.invoke(ui as *const _ as *const _)).response })
    // Bindings for Grid
    .with(EguiFn::egui_grid_Grid_show, |mut ui: EguiPointer<Ui>, grid: Grid, callback: EguiCallback| unsafe {
        grid.show(ui.get_mut(), |ui| {
            callback.invoke(ui as *const _ as *const _);
        }).response
    })
    // Bindings for HexColor
    .with(EguiFn::ecolor_hex_color_runtime_HexColor_from_str, |x: String| <HexColor as std::str::FromStr>::from_str(&x).ok())
    .with(EguiFn::ecolor_hex_color_runtime_HexColor_from_str_without_hash, |x: String| HexColor::from_str_without_hash(&x).ok())
    // Bindings for Hsva
    .with(EguiFn::ecolor_hsva_Hsva_from_additive_srgb, |x: [u8; 3]| Hsva::from_additive_srgb(x))
    .with(EguiFn::ecolor_hsva_Hsva_from_srgb, |x: [u8; 3]| Hsva::from_srgb(x))
    .with(EguiFn::ecolor_hsva_Hsva_from_srgba_premultiplied, |x: [u8; 4]| Hsva::from_srgba_premultiplied(x))
    .with(EguiFn::ecolor_hsva_Hsva_from_srgba_unmultiplied, |x: [u8; 4]| Hsva::from_srgba_unmultiplied(x))
    // Bindings for Id
    .with(EguiFn::egui_id_Id_new, |source: String| Id::new(source))
    .with(EguiFn::egui_id_Id_with, |this: Id, child: String| this.with(child))
    // Bindings for Modal
    .with(EguiFn::egui_containers_modal_Modal_show, |ctx: EguiPointer<Context>, obj: Modal, callback: EguiCallback| unsafe {
        let result = obj.show(ctx.get(), |ui| {
            callback.invoke(ui as *const _ as *const _);
        });

        (result.response, result.backdrop_response, result.is_top_modal, result.any_popup_open)
    })
    // Bindings for ModalResponse
    .with(EguiFn::egui_containers_modal_ModalResponse_should_close, |response: Response, backdrop_response: Response, is_top_modal: bool, any_popup_open: bool| ModalResponse {
        response,
        backdrop_response,
        inner: (),
        is_top_modal,
        any_popup_open
    }.should_close())
    // Bindings for Painter
    .with(EguiFn::egui_painter_Painter_new, |ctx: EguiPointer<Context>, layer_id: LayerId, clip_rect: Rect| unsafe { EguiHandle::to_heap(Painter::new(ctx.get().clone(), layer_id, clip_rect)) })
    .with(EguiFn::egui_painter_Painter_with_layer_id, |painter: EguiPointer<Painter>, layer_id: LayerId| unsafe { EguiHandle::to_heap(painter.get().clone().with_layer_id(layer_id)) })
    .with(EguiFn::egui_painter_Painter_with_clip_rect, |painter: EguiPointer<Painter>, clip_rect: Rect| unsafe { EguiHandle::to_heap(painter.get().clone().with_clip_rect(clip_rect)) })
    .with(EguiFn::egui_painter_Painter_add, |painter: EguiPointer<Painter>, shape: Shape| unsafe { painter.get().add(shape) })
    // Bindings for Popup
    .with(EguiFn::egui_containers_popup_Popup_close_all, |ctx: EguiPointer<Context>| unsafe { Popup::close_all(ctx.get()) })
    .with(EguiFn::egui_containers_popup_Popup_close_id, |ctx: EguiPointer<Context>, id: Id| unsafe { Popup::close_id(ctx.get(), id) })
    .with(EguiFn::egui_containers_popup_Popup_open_id, |ctx: EguiPointer<Context>, id: Id| unsafe { Popup::open_id(ctx.get(), id) })
    .with(EguiFn::egui_containers_popup_Popup_toggle_id, |ctx: EguiPointer<Context>, id: Id| unsafe { Popup::toggle_id(ctx.get(), id) })
    .with(EguiFn::egui_containers_popup_Popup_is_any_open, |ctx: EguiPointer<Context>| unsafe { Popup::is_any_open(ctx.get()) })
    .with(EguiFn::egui_containers_popup_Popup_is_id_open, |ctx: EguiPointer<Context>, id: Id| unsafe { Popup::is_id_open(ctx.get(), id) })
    .with(EguiFn::egui_containers_popup_Popup_position_of_id, |ctx: EguiPointer<Context>, id: Id| unsafe { Popup::position_of_id(ctx.get(), id) })
    .with(EguiFn::egui_containers_popup_Popup_show, |ctx: EguiPointer<Context>, popup: SerializablePopup, mut is_open: bool, callback: EguiCallback| unsafe {
        let response = popup.to_popup(ctx.get(), &mut is_open).show(|ui| callback.invoke(ui as *const _ as *const _));
        (response.map(|x| x.response), is_open)
    })
    // Bindings for RawInput
    .with(EguiFn::egui_data_input_RawInput_append, |mut this: RawInput, newer: RawInput| {
        this.append(newer);
        this
    })
    .with(EguiFn::egui_data_input_RawInput_take, |mut this: RawInput| {
        let new = this.take();
        (this, new)
    })
    .with(EguiFn::egui_data_input_RawInput_viewport, |this: RawInput| this.viewport().clone())
    // Bindings for Rect
    .with(EguiFn::emath_rect_Rect_center, |r: Rect| r.center())
    .with(EguiFn::emath_rect_Rect_set_center, |mut r: Rect, p: Pos2| { r.set_center(p); r })
    .with(EguiFn::emath_rect_Rect_extend_with, |mut r: Rect, p: Pos2| { r.extend_with(p); r })
    .with(EguiFn::emath_rect_Rect_extend_with, |mut r: Rect, p: Pos2| { r.extend_with(p); r })
    .with(EguiFn::emath_rect_Rect_extend_with_x, |mut r: Rect, p: f32| { r.extend_with_x(p); r })
    .with(EguiFn::emath_rect_Rect_extend_with_y, |mut r: Rect, p: f32| { r.extend_with_y(p); r })
    // Bindings for RectAlign
    .with(EguiFn::emath_rect_align_RectAlign_find_best_align, |values_to_try: Vec<RectAlign>, screen_rect: Rect, parent_rect: Rect, gap: f32, expected_size: Vec2| RectAlign::find_best_align(values_to_try.into_iter(), screen_rect, parent_rect, gap, expected_size))
    // Bindings for Resize
    .with(EguiFn::egui_containers_resize_Resize_show, |mut ui: EguiPointer<Ui>, obj: Resize, callback: EguiCallback| unsafe { obj.show(ui.get_mut(), |ui| callback.invoke(ui as *const _ as *const _)) })
    // Bindings for Response
    .with(EguiFn::egui_response_Response_mark_changed, |mut x: Response| { x.mark_changed(); x })
    .with(EguiFn::egui_response_Response_mark_changed, |mut x: Response| { x.set_close(); x })
    .with(EguiFn::egui_response_Response_widget_info, |x: Response, info: WidgetInfo| x.widget_info(|| info.clone()))
    // Bindings for Scene
    .with(EguiFn::egui_containers_scene_Scene_show, |mut ui: EguiPointer<Ui>, scene: Scene, mut scene_rect: Rect, callback: EguiCallback| unsafe { (scene.show(ui.get_mut(), &mut scene_rect, |ui| callback.invoke(ui as *const _ as *const _)).response, scene_rect) })
    // Bindings for Sense
    .with(EguiFn::egui_sense_Sense_interactive, |x: u8| Sense::from_bits_truncate(x).interactive())
    .with(EguiFn::egui_sense_Sense_senses_click, |x: u8| Sense::from_bits_truncate(x).senses_click())
    .with(EguiFn::egui_sense_Sense_senses_drag, |x: u8| Sense::from_bits_truncate(x).senses_drag())
    .with(EguiFn::egui_sense_Sense_is_focusable, |x: u8| Sense::from_bits_truncate(x).is_focusable())
    // Bindings for SidePanel
    .with(EguiFn::egui_containers_panel_SidePanel_show, |ctx: EguiPointer<Context>, panel: SidePanel, callback: EguiCallback| unsafe { panel.show(ctx.get(), |ui| callback.invoke(ui as *const _ as *const _)).response })
    .with(EguiFn::egui_containers_panel_SidePanel_show_inside, |mut ui: EguiPointer<Ui>, panel: SidePanel, callback: EguiCallback| unsafe { panel.show_inside(ui.get_mut(), |ui| callback.invoke(ui as *const _ as *const _)).response })
    .with(EguiFn::egui_containers_panel_SidePanel_show_animated_inside, |mut ui: EguiPointer<Ui>, is_expanded: bool, panel: SidePanel, callback: EguiCallback| unsafe { panel.show_animated_inside(ui.get_mut(), is_expanded, |ui| callback.invoke(ui as *const _ as *const _)).map(|x| x.response) })
    .with(EguiFn::egui_containers_panel_SidePanel_show_animated, |ctx: EguiPointer<Context>, is_expanded: bool, panel: SidePanel, callback: EguiCallback| unsafe { panel.show_animated(ctx.get(), is_expanded, |ui| callback.invoke(ui as *const _ as *const _)).map(|x| x.response) })
    .with(EguiFn::egui_containers_panel_SidePanel_show_animated_between, |ctx: EguiPointer<Context>, is_expanded: bool, collapsed_panel: SidePanel, expanded_panel: SidePanel, callback: EguiCallback| unsafe { SidePanel::show_animated_between(ctx.get(), is_expanded, collapsed_panel, expanded_panel, |ui, t| callback.invoke(&EguiAnimatedUi::new(ui, t) as *const _ as *const _)).map(|x| x.response) })
    .with(EguiFn::egui_containers_panel_SidePanel_show_animated_between_inside, |mut ui: EguiPointer<Ui>, is_expanded: bool, collapsed_panel: SidePanel, expanded_panel: SidePanel, callback: EguiCallback| unsafe { SidePanel::show_animated_between_inside(ui.get_mut(), is_expanded, collapsed_panel, expanded_panel, |ui, t| callback.invoke(&EguiAnimatedUi::new(ui, t) as *const _ as *const _)).response })
    // Bindings for Sides
    .with(EguiFn::egui_containers_sides_Sides_show, |mut ui: EguiPointer<Ui>, obj: Sides, l_callback: EguiCallback, r_callback: EguiCallback| unsafe { obj.show(ui.get_mut(), |ui| l_callback.invoke(ui as *const _ as *const _), |ui| r_callback.invoke(ui as *const _ as *const _)) })
    // Bindings for Slider
    .with(EguiFn::egui_widgets_slider_Slider_ui, |mut ui: EguiPointer<Ui>, obj: SerializableSlider, mut value: f64| unsafe {
        (ui.get_mut().add(obj.to_slider(&mut value)), value)
    })
    // Bindings for TextEdit
    .with(EguiFn::egui_widgets_text_edit_builder_TextEdit_ui, |mut ui: EguiPointer<Ui>, obj: SerializableTextEdit, mut text: String, editable: bool| unsafe {
        if editable {
            (ui.get_mut().add(obj.to_text_edit(&mut text)), text)
        }
        else {
            (ui.get_mut().add(obj.to_text_edit(&mut text.as_str())), String::default())
        }
    })
    // Bindings for TopBottomPanel
    .with(EguiFn::egui_containers_panel_TopBottomPanel_show, |ctx: EguiPointer<Context>, panel: TopBottomPanel, callback: EguiCallback| unsafe { panel.show(ctx.get(), |ui| callback.invoke(ui as *const _ as *const _)).response })
    .with(EguiFn::egui_containers_panel_TopBottomPanel_show_inside, |mut ui: EguiPointer<Ui>, panel: TopBottomPanel, callback: EguiCallback| unsafe { panel.show_inside(ui.get_mut(), |ui| callback.invoke(ui as *const _ as *const _)).response })
    .with(EguiFn::egui_containers_panel_TopBottomPanel_show_animated_inside, |mut ui: EguiPointer<Ui>, is_expanded: bool, panel: TopBottomPanel, callback: EguiCallback| unsafe { panel.show_animated_inside(ui.get_mut(), is_expanded, |ui| callback.invoke(ui as *const _ as *const _)).map(|x| x.response) })
    .with(EguiFn::egui_containers_panel_TopBottomPanel_show_animated, |ctx: EguiPointer<Context>, is_expanded: bool, panel: TopBottomPanel, callback: EguiCallback| unsafe { panel.show_animated(ctx.get(), is_expanded, |ui| callback.invoke(ui as *const _ as *const _)).map(|x| x.response) })
    .with(EguiFn::egui_containers_panel_TopBottomPanel_show_animated_between, |ctx: EguiPointer<Context>, is_expanded: bool, collapsed_panel: TopBottomPanel, expanded_panel: TopBottomPanel, callback: EguiCallback| unsafe { TopBottomPanel::show_animated_between(ctx.get(), is_expanded, collapsed_panel, expanded_panel, |ui, t| callback.invoke(&EguiAnimatedUi::new(ui, t) as *const _ as *const _)).map(|x| x.response) })
    .with(EguiFn::egui_containers_panel_TopBottomPanel_show_animated_between_inside, |mut ui: EguiPointer<Ui>, is_expanded: bool, collapsed_panel: TopBottomPanel, expanded_panel: TopBottomPanel, callback: EguiCallback| unsafe { TopBottomPanel::show_animated_between_inside(ui.get_mut(), is_expanded, collapsed_panel, expanded_panel, |ui, t| callback.invoke(&EguiAnimatedUi::new(ui, t) as *const _ as *const _)).response })
    // Bindings for Tooltip
    .with(EguiFn::egui_containers_tooltip_Tooltip_show, |ctx: EguiPointer<Context>, popup: SerializablePopup, parent_layer: LayerId, parent_widget: Id, callback: EguiCallback| unsafe {
        (Tooltip {
            popup: popup.to_popup(ctx.get(), &mut true),
            parent_layer,
            parent_widget
        }.show(|ui| callback.invoke(ui as *const _ as *const _)).map(|x| x.response), true)
    })
    // Bindings for Ui
    .with(EguiFn::egui_ui_Ui_allocate_painter, |mut ui: EguiPointer<Ui>, desired_size: Vec2, sense: Sense| unsafe {
        let (response, painter) = ui.get_mut().allocate_painter(desired_size, sense);
        (response, EguiHandle::to_heap(painter))
    })
    .with(EguiFn::egui_ui_Ui_painter, |ui: EguiPointer<Ui>| unsafe { EguiHandle::to_heap(ui.get().painter().clone()) })
    .with(EguiFn::egui_ui_Ui_painter_at, |ui: EguiPointer<Ui>, rect: Rect| unsafe { EguiHandle::to_heap(ui.get().painter_at(rect)) })
    .with(EguiFn::egui_ui_Ui_spacing, |ui: EguiPointer<Ui>| unsafe { ui.get().spacing().clone() })
    .with(EguiFn::egui_ui_Ui_style, |ui: EguiPointer<Ui>| unsafe { ui.get().style().clone() })
    .with(EguiFn::egui_ui_Ui_layout, |ui: EguiPointer<Ui>| unsafe { ui.get().layout().clone() })
    .with(EguiFn::egui_ui_Ui_visuals, |ui: EguiPointer<Ui>| unsafe { ui.get().visuals().clone() })
    .with(EguiFn::egui_ui_Ui_stack, |ui: EguiPointer<Ui>| unsafe { ui.get().stack().clone() })
    .with(EguiFn::egui_ui_Ui_separator, |mut ui: EguiPointer<Ui>| unsafe { ui.get_mut().separator() })
    .with(EguiFn::egui_ui_Ui_set_enabled, |mut ui: EguiPointer<Ui>, enabled: bool| unsafe { ui.get_mut().set_enabled(enabled) })
    .with(EguiFn::egui_ui_Ui_group, |mut ui: EguiPointer<Ui>, callback: EguiCallback| unsafe { ui.get_mut().group(|ui| callback.invoke(ui as *const _ as *const _)).response })
    .with(EguiFn::egui_ui_Ui_horizontal, |mut ui: EguiPointer<Ui>, callback: EguiCallback| unsafe { ui.get_mut().horizontal(|ui| callback.invoke(ui as *const _ as *const _)).response })
    .with(EguiFn::egui_ui_Ui_horizontal_centered, |mut ui: EguiPointer<Ui>, callback: EguiCallback| unsafe { ui.get_mut().horizontal_centered(|ui| callback.invoke(ui as *const _ as *const _)).response })
    .with(EguiFn::egui_ui_Ui_horizontal_top, |mut ui: EguiPointer<Ui>, callback: EguiCallback| unsafe { ui.get_mut().horizontal_top(|ui| callback.invoke(ui as *const _ as *const _)).response })
    .with(EguiFn::egui_ui_Ui_horizontal_wrapped, |mut ui: EguiPointer<Ui>, callback: EguiCallback| unsafe { ui.get_mut().horizontal_wrapped(|ui| callback.invoke(ui as *const _ as *const _)).response })
    .with(EguiFn::egui_ui_Ui_vertical, |mut ui: EguiPointer<Ui>, callback: EguiCallback| unsafe { ui.get_mut().vertical(|ui| callback.invoke(ui as *const _ as *const _)).response })
    .with(EguiFn::egui_ui_Ui_vertical_centered, |mut ui: EguiPointer<Ui>, callback: EguiCallback| unsafe { ui.get_mut().vertical_centered(|ui| callback.invoke(ui as *const _ as *const _)).response })
    .with(EguiFn::egui_ui_Ui_vertical_centered_justified, |mut ui: EguiPointer<Ui>, callback: EguiCallback| unsafe { ui.get_mut().vertical_centered_justified(|ui| callback.invoke(ui as *const _ as *const _)).response })
    .with(EguiFn::egui_ui_Ui_centered_and_justified, |mut ui: EguiPointer<Ui>, callback: EguiCallback| unsafe { ui.get_mut().centered_and_justified(|ui| callback.invoke(ui as *const _ as *const _)).response })
    .with(EguiFn::egui_ui_Ui_scope_builder, |mut ui: EguiPointer<Ui>, ui_builder: UiBuilder, callback: EguiCallback| unsafe { ui.get_mut().scope_builder(ui_builder, |ui| callback.invoke(ui as *const _ as *const _)).response })
    .with(EguiFn::egui_ui_Ui_indent, |mut ui: EguiPointer<Ui>, id_salt: Id, callback: EguiCallback| unsafe { ui.get_mut().indent(id_salt, |ui| callback.invoke(ui as *const _ as *const _)).response })
    .with(EguiFn::egui_ui_Ui_with_visual_transform, |mut ui: EguiPointer<Ui>, transform: TSTransform, callback: EguiCallback| unsafe { ui.get_mut().with_visual_transform(transform, |ui| callback.invoke(ui as *const _ as *const _)).response })
    .with(EguiFn::egui_ui_Ui_allocate_ui_with_layout, |mut ui: EguiPointer<Ui>, desired_size: Vec2, layout: Layout, callback: EguiCallback| unsafe { ui.get_mut().allocate_ui_with_layout(desired_size, layout, |ui| callback.invoke(ui as *const _ as *const _)).response })
    .with(EguiFn::egui_ui_Ui_columns, |mut ui: EguiPointer<Ui>, num_columns: usize, callback: EguiCallback| unsafe {
        ui.get_mut().columns(num_columns, |ui_list| callback.invoke(ui_list.iter_mut().map(|x| x as *const _ as *const _).collect::<Vec<*const c_void>>().as_ptr() as *const _))
    })
    // Bindings for WidgetText
    .with(EguiFn::egui_widget_text_WidgetText_text, |x: WidgetText| x.text().to_string())
    // Bindings for Window
    .with(EguiFn::egui_containers_window_Window_show, |ctx: EguiPointer<Context>, window: SerializableWindow, open: Option<bool>, add_contents: EguiCallback| unsafe {
        let window = Window::from(window);
        if let Some(mut is_open) = open {
            let response = window.open(&mut is_open).show(ctx.get(), |ui| add_contents.invoke(ui as *const _ as *const _));
            (response.map(|x| x.response), is_open)
        }
        else {
            let response = window.show(ctx.get(), |ui| add_contents.invoke(ui as *const _ as *const _));
            (response.map(|x| x.response), true)
        }
    })
    // Miscellaneous
    .with(EguiFn::emath_format_with_decimals_in_range, format_with_decimals_in_range as fn(f64, RangeInclusive<usize>) -> _);

/// Callback data for a UI and time.
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EguiAnimatedUi {
    /// A pointer to the UI.
    pub ui: usize,
    /// The animation time.
    pub t: f32
}

impl EguiAnimatedUi {
    /// Creates a new animated UI instance.
    pub fn new(ui: &mut Ui, t: f32) -> Self {
        Self {
            ui: ui as *const _ as usize,
            t
        }
    }
}

/// A C# callback for `egui` to invoke.
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EguiCallback {
    /// The function to call.
    func: unsafe extern "C" fn(*const c_void, *const c_void),
    /// Data to pass as the second function argument.
    data: *const c_void
}

unsafe impl Send for EguiCallback {}
unsafe impl Sync for EguiCallback {}

impl EguiCallback {
    /// Invokes the callback.
    /// 
    /// # Safety
    /// 
    /// All invariants for [`Self::func`] must be satisfied.
    pub unsafe fn invoke(&self, argument: *const c_void) {
        (self.func)(argument, self.data)
    }
}

impl Serialize for EguiCallback {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: Serializer {
        [self.func as usize, self.data as usize].serialize(serializer)
    }
}

impl<'a> Deserialize<'a> for EguiCallback {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: Deserializer<'a> {
        unsafe {
            let [func, data] = <[usize; 2] as Deserialize<'a>>::deserialize(deserializer)?;
            Ok(Self {
                func: transmute(func),
                data: data as *const _
            })
        }
    }
}

/// An `egui` object that is passed by reference.
#[derive(Copy, Clone, Serialize, Deserialize)]
#[repr(C)]
pub struct EguiPointer<T> {
    /// The underlying pointer.
    ptr: usize,
    /// Marker data identifying the type.
    marker: PhantomData<*mut T>
}

impl<T> EguiPointer<T> {
    /// Gets a reference to the underlying object.
    /// 
    /// # Safety
    /// 
    /// The pointer must be valid, and no mutable references may exist to it.
    pub unsafe fn get(&self) -> &T {
        assert_ne!(self.ptr, 0, "egui object was not initialized");
        &*(self.ptr as *const _)
    }

    /// Gets a mutable reference to the underlying object.
    /// 
    /// # Safety
    /// 
    /// The pointer must be valid, and no other references may exist to it.
    pub unsafe fn get_mut(&mut self) -> &mut T {
        assert_ne!(self.ptr, 0, "egui object was not initialized");
        &mut *(self.ptr as *mut _)
    }
}

/// Represents a heap-allocated `egui` object.
#[derive(Copy, Clone, Serialize, Deserialize)]
#[repr(C)]
pub struct EguiHandle {
    /// A pointer to the object.
    ptr: usize,
    /// Metadata about the pointer used for internal purposes.
    metadata: usize
}

impl EguiHandle {
    /// Allocates `value` on the heap and returns a handle to it.
    pub fn to_heap<T: 'static>(value: T) -> Self {
        let ptr = Box::into_raw(Box::new(value)) as usize;
        let metadata = std::ptr::drop_in_place::<T> as usize;
        Self {
            ptr,
            metadata
        }
    }
}

/// Describes the result of an `egui` call.
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EguiInvokeResult {
    /// Whether `return_value` holds a serialized value or an error string.
    pub success: bool,
    /// If [`Self::success`], then the serialized data that the function returned.
    /// Otherwise, holds a UTF8 string describing what went wrong.
    pub return_value: EguiSliceU8
}

/// Describes a section of a `u8` array.
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EguiSliceU8 {
    /// A pointer to the data buffer.
    pub ptr: *const u8,
    /// The length of the data in bytes.
    pub len: usize
}

impl EguiSliceU8 {
    /// Converts `x` to an FFI-compatible slice.
    /// 
    /// # Safety
    /// 
    /// The lifetime of the returned slice should not outlive `x`. 
    pub const fn from_slice(x: &[u8]) -> Self {
        Self {
            ptr: x.as_ptr(),
            len: x.len()
        }
    }

    /// Converts this object to a Rust slice pointer.
    /// 
    /// # Safety
    /// 
    /// For this function call to be sound, `self` must refer
    /// to a valid array of `u8` with at least [`Self::len`] elements.
    pub unsafe fn to_ptr(&self) -> *const [u8] {
        if self.len == 0 {
            &[]
        }
        else {
            std::slice::from_raw_parts(self.ptr, self.len)
        }
    }

    /// Converts this object to a Rust slice.
    /// 
    /// # Safety
    /// 
    /// For this function call to be sound, `self` must refer
    /// to a valid array of `u8` with at least [`Self::len`] elements.
    pub unsafe fn to_slice(&self) -> &[u8] {
        if self.len == 0 {
            &[]
        }
        else {
            std::slice::from_raw_parts(self.ptr, self.len)
        }
    }
}

/// Initializes the `egui` bindings library.
#[no_mangle]
pub unsafe extern "C" fn egui_init() {
    panic::set_hook(Box::new(|_| ()));
}

#[no_mangle]
pub unsafe extern "C" fn egui_invoke(f: EguiFn, args: EguiSliceU8) -> EguiInvokeResult {
    /// The serialization buffer to which results will be written.
    #[thread_local]
    static mut RETURN_BUFFER: Vec<u8> = Vec::new();

    match catch_unwind(|| {
        if let Some(invoker) = EGUI_FNS.inner[f as usize] {
            invoker.invoke(args.to_ptr(), std::ptr::addr_of_mut!(RETURN_BUFFER));
            EguiInvokeResult {
                success: true,
                return_value: EguiSliceU8::from_slice(&*std::ptr::addr_of_mut!(RETURN_BUFFER))
            }
        }
        else {
            panic!("Function {f:?} not implemented")
        }
    }) {
        Ok(x) => x,
        Err(error) => {
            let error_message = error.downcast_ref::<&'static str>()
                .map(|x| x.to_string())
                .unwrap_or_else(|| error.downcast_ref::<String>().cloned().unwrap_or_default());
            
            let return_buffer = &mut *std::ptr::addr_of_mut!(RETURN_BUFFER);
            return_buffer.clear();
            for character in error_message.encode_utf16() {
                return_buffer.extend(character.to_ne_bytes());
            }

            EguiInvokeResult {
                success: false,
                return_value: EguiSliceU8::from_slice(&return_buffer)
            }
        }
    }
}

/// Frees an `egui` object from the heap.
#[no_mangle]
pub unsafe extern "C" fn egui_drop(handle: EguiHandle) {
    transmute::<_, unsafe fn(usize)>(handle.metadata)(handle.ptr)
}

/// Holds bindings for all `egui` functions and allows for translating from [`EguiFn`] names to function pointers.
struct EguiFnMap {
    /// A mapping from [`EguiFn`] bindings to the underlying function to invoke.
    inner: [Option<EguiFnInvoker>; EguiFn::ALL.len()]
}

impl EguiFnMap {
    /// Adds a function (that has call-by-value semantics) and returns the new map.
    pub const fn with<A: DeserializeOwned + Tuple, R: Serialize>(mut self, binding: EguiFn, f: impl Copy + Fn<A, Output = R>) -> Self {
        self.inner[binding as usize] = Some(EguiFnInvoker::new(f));
        self
    }
}

/// Creates a new, empty function map.
const fn egui_fn_map() -> EguiFnMap {
    EguiFnMap {
        inner: [None; EguiFn::ALL.len()]
    }
}

/// A type-erased `egui` function that may be called with serialized arguments/result.
#[derive(Copy, Clone, Debug)]
struct EguiFnInvoker {
    /// The `fn` object to pass to `func`.
    data: *const (),
    /// The [`EguiFnInvokable::invoke`] method to call.
    func: unsafe fn(*const (), *const [u8], *mut Vec<u8>)
}

impl EguiFnInvoker {
    /// Stores the provided [`EguiFnInvokable`] on the stack for later use.
    /// `F` should be a `fn` pointer.
    pub const fn new<A: DeserializeOwned + Tuple, F: Copy + Fn<A, Output: Serialize>>(f: F) -> Self {
        unsafe {
            /// Allows for safely reading the data of `f`.
            #[repr(C)]
            struct PaddedPtr<F> {
                /// The function being called.
                pub f: F,
                /// Padding for when `F` is less than the size of a pointer.
                pub padding: *const ()
            }

            if size_of::<*const ()>() < size_of::<F>() || align_of::<*const ()>() < align_of::<F>() {
                panic!("Invokable function must be thin pointer");
            }

            let padded = PaddedPtr { f, padding: std::ptr::null() };

            Self {
                data: std::ptr::read(&padded as *const _ as *const _),
                func: transmute(Self::call_fn::<A, F> as unsafe fn(_, _, _))
            }
        }
    }

    /// Invokes the underlying function.
    /// 
    /// # Safety
    /// 
    /// For this function call to be sound, `ptr` must refer to a valid instance
    /// of the invoker function's type. 
    pub unsafe fn invoke(&self, args: *const [u8], ret: *mut Vec<u8>) {
        (self.func)(&self.data as *const _ as *const _, args, ret)
    }

    /// Invokes the underlying function.
    /// 
    /// # Safety
    /// 
    /// For this function call to be sound, `ptr` must refer to a valid instance
    /// of the invoker function's type. 
    unsafe fn call_fn<A: DeserializeOwned + Tuple, F: Copy + Fn<A, Output: Serialize>>(f: &F, args: *const [u8], ret: *mut Vec<u8>) {
        let deserialized_args = bincode::deserialize(&*args).expect("Failed to decode args");
        let result = f.call(deserialized_args);
        (*ret).clear();
        bincode::serialize_into(&mut *ret, &result).expect("Failed to encode result");
    }
}

/// Helper struct for serializing popups
#[derive(Clone, Serialize, Deserialize)]
struct SerializablePopup {
    pub id: Id,
    pub anchor: PopupAnchor,
    pub rect_align: RectAlign,
    pub alternative_aligns: Option<Vec<RectAlign>>,
    pub layer_id: LayerId,
    pub open_kind: u8,
    pub open_command: Option<SetOpenCommand>,
    pub close_behavior: PopupCloseBehavior,
    pub info: Option<UiStackInfo>,
    pub kind: PopupKind,
    pub gap: f32,
    pub widget_clicked_elsewhere: bool,
    pub width: Option<f32>,
    pub sense: Sense,
    pub layout: Layout,
    pub frame: Option<Frame>,
    pub style: Option<Style>,
    pub menu_style: bool
}

impl SerializablePopup {
    pub fn to_popup<'a>(&'a self, ctx: &Context, open_bool: &'a mut bool) -> Popup<'a> {
        Popup {
            id: self.id,
            open_kind: match self.open_kind {
                0 => OpenKind::Open,
                1 => OpenKind::Closed,
                2 => OpenKind::Bool(open_bool),
                3 => OpenKind::Memory { set: self.open_command.clone() },
                _ => panic!("Invalid open kind value")
            },
            ctx: ctx.clone(),
            anchor: self.anchor,
            rect_align: self.rect_align,
            alternative_aligns: self.alternative_aligns.as_deref(),
            layer_id: self.layer_id,
            close_behavior: self.close_behavior,
            info: self.info.clone(),
            kind: self.kind,
            gap: self.gap,
            widget_clicked_elsewhere: self.widget_clicked_elsewhere,
            width: self.width,
            sense: self.sense,
            layout: self.layout,
            frame: self.frame,
            style: if self.menu_style {
                StyleModifier::from(menu_style)
            } else if let Some(style) = &self.style {
                style.clone().into()
            }
            else {
                StyleModifier::default()
            },
        }
    }
}

/// Helper struct for serializing windows
#[derive(Clone, Serialize, Deserialize)]
struct SerializableWindow {
    title: WidgetText,
    area: Area,
    frame: Option<Frame>,
    resize: Resize,
    scroll: ScrollArea,
    collapsible: bool,
    default_open: bool,
    with_title_bar: bool,
    fade_out: bool,
}

impl<'a> From<SerializableWindow> for Window<'a> {
    fn from(value: SerializableWindow) -> Self {
        Window {
            title: value.title,
            open: None,
            area: value.area,
            frame: value.frame,
            resize: value.resize,
            scroll: value.scroll,
            collapsible: value.collapsible,
            default_open: value.default_open,
            with_title_bar: value.with_title_bar,
            fade_out: value.fade_out
        }
    }
}

#[derive(Serialize, Deserialize)]
struct SerializableTextEdit {
    pub hint_text: WidgetText,
    pub hint_text_font: Option<FontSelection>,
    pub id: Option<Id>,
    pub id_salt: Option<Id>,
    pub font_selection: FontSelection,
    pub text_color: Option<Color32>,
    pub password: bool,
    pub frame: bool,
    pub margin: Margin,
    pub multiline: bool,
    pub interactive: bool,
    pub desired_width: Option<f32>,
    pub desired_height_rows: usize,
    pub event_filter: EventFilter,
    pub cursor_at_end: bool,
    pub min_size: Vec2,
    pub align: Align2,
    pub clip_text: bool,
    pub char_limit: usize,
    pub return_key: Option<KeyboardShortcut>,
    pub background_color: Option<Color32>,
}

impl SerializableTextEdit {
    /// Converts this to a usable [`TextEdit`] widget.
    pub fn to_text_edit<'a>(self, text: &'a mut impl TextBuffer) -> TextEdit {
        TextEdit {
            text,
            hint_text: self.hint_text,
            hint_text_font: self.hint_text_font,
            id: self.id,
            id_salt: self.id_salt,
            font_selection: self.font_selection,
            text_color: self.text_color,
            password: self.password,
            frame: self.frame,
            layouter: None,
            margin: self.margin,
            multiline: self.multiline,
            interactive: self.interactive,
            desired_width: self.desired_width,
            desired_height_rows: self.desired_height_rows,
            event_filter: self.event_filter,
            cursor_at_end: self.cursor_at_end,
            min_size: self.min_size,
            align: self.align,
            clip_text: self.clip_text,
            char_limit: self.char_limit,
            return_key: self.return_key,
            background_color: self.background_color,
        }
    }
}

#[derive(Clone, Serialize, Deserialize)]
pub struct SerializableDragValue {
    speed: f64,
    prefix: String,
    suffix: String,
    start: f64,
    end: f64,
    clamp_existing_to_range: bool,
    min_decimals: usize,
    max_decimals: Option<usize>,
    update_while_editing: bool,
    min_width: usize,
    twos_complement: bool,
    upper: bool,
    parser: u8
}

impl SerializableDragValue {
    /// Converts this to a usable [`DragValue`] widget.
    pub fn to_drag_value<'a>(self, value: &'a mut f64) -> DragValue<'a> {
        let mut result = DragValue::new(value)
            .speed(self.speed)
            .prefix(self.prefix)
            .suffix(self.suffix)
            .range(self.start..=self.end)
            .clamp_existing_to_range(self.clamp_existing_to_range)
            .min_decimals(self.min_decimals)
            .max_decimals_opt(self.max_decimals)
            .update_while_editing(self.update_while_editing);

        match self.parser {
            0 => result,
            2 => result.binary(self.min_width, self.twos_complement),
            8 => result.octal(self.min_width, self.twos_complement),
            16 => result.hexadecimal(self.min_width, self.twos_complement, self.upper),
            _ => panic!("Unrecognized DragValue parser type")
        }
    }
}

#[derive(Clone, serde::Serialize, serde::Deserialize)]
struct SerializableSlider {
    pub start: f64,
    pub end: f64,
    pub spec: SliderSpec,
    pub clamping: SliderClamping,
    pub smart_aim: bool,
    pub show_value: bool,
    pub orientation: SliderOrientation,
    pub prefix: String,
    pub suffix: String,
    pub text: WidgetText,
    pub step: Option<f64>,
    pub drag_value_speed: Option<f64>,
    pub min_decimals: usize,
    pub max_decimals: Option<usize>,
    pub trailing_fill: Option<bool>,
    pub handle_shape: Option<HandleShape>,
    pub update_while_editing: bool,
    pub min_width: usize,
    pub twos_complement: bool,
    pub upper: bool,
    pub parser: u8,
}

impl SerializableSlider {
    /// Converts this to a usable [`Slider`] widget.
    pub fn to_slider<'a>(self, value: &'a mut f64) -> Slider<'a> {
        let mut result = Slider {
            spec: self.spec,
            clamping: self.clamping,
            smart_aim: self.smart_aim,
            show_value: self.show_value,
            orientation: self.orientation,
            prefix: self.prefix,
            suffix: self.suffix,
            text: self.text,
            step: self.step,
            drag_value_speed: self.drag_value_speed,
            min_decimals: self.min_decimals,
            max_decimals: self.max_decimals,
            trailing_fill: self.trailing_fill,
            handle_shape: self.handle_shape,
            update_while_editing: self.update_while_editing,
            ..Slider::new(value, self.start..=self.end)
        };

        match self.parser {
            0 => result,
            2 => result.binary(self.min_width, self.twos_complement),
            8 => result.octal(self.min_width, self.twos_complement),
            16 => result.hexadecimal(self.min_width, self.twos_complement, self.upper),
            _ => panic!("Unrecognized DragValue parser type")
        }
    }
}

/// Functions that can be run as tests.
#[cfg(test)]
mod tests {
    use super::*;
    
    /// Creates a list of all unbound methods and stubs for them. 
    #[test]
    fn report_unbound_methods() {
        let mut result = String::new();
        let mut bound = 0;

        for func in EguiFn::ALL {
            if EGUI_FNS.inner[*func as usize].is_none() {
                result += &format!("{func:?}\n");
            }
            else {
                bound += 1;
            }
        }
        
        result = format!("{bound} / {} ({}%) bound\n{result}", EguiFn::ALL.len(), (100.0 * bound as f32 / EguiFn::ALL.len() as f32).floor());
        std::fs::write("progress_report.txt", result).expect("Failed to write progress report");
    }
}